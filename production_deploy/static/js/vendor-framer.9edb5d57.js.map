{"version":3,"file":"static/js/vendor-framer.9edb5d57.js","mappings":"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","sources":["../node_modules/framer-motion/dist/es/render/svg/lowercase-elements.mjs","../node_modules/framer-motion/dist/es/render/dom/utils/is-svg-component.mjs","../node_modules/framer-motion/dist/es/render/dom/create-visual-element.mjs","../node_modules/framer-motion/dist/es/context/LayoutGroupContext.mjs","../node_modules/framer-motion/dist/es/context/LazyContext.mjs","../node_modules/framer-motion/dist/es/context/MotionConfigContext.mjs","../node_modules/framer-motion/dist/es/context/MotionContext/index.mjs","../node_modules/framer-motion/dist/es/context/MotionContext/create.mjs","../node_modules/framer-motion/dist/es/context/MotionContext/utils.mjs","../node_modules/framer-motion/dist/es/render/html/utils/create-render-state.mjs","../node_modules/framer-motion/dist/es/render/html/use-props.mjs","../node_modules/framer-motion/dist/es/render/svg/utils/create-render-state.mjs","../node_modules/framer-motion/dist/es/render/svg/use-props.mjs","../node_modules/framer-motion/dist/es/motion/utils/valid-prop.mjs","../node_modules/framer-motion/dist/es/render/dom/utils/filter-props.mjs","../node_modules/framer-motion/dist/es/render/dom/use-render.mjs","../node_modules/framer-motion/dist/es/context/PresenceContext.mjs","../node_modules/framer-motion/dist/es/motion/utils/use-visual-state.mjs","../node_modules/framer-motion/dist/es/utils/use-constant.mjs","../node_modules/framer-motion/dist/es/render/html/use-html-visual-state.mjs","../node_modules/framer-motion/dist/es/render/svg/use-svg-visual-state.mjs","../node_modules/framer-motion/dist/es/utils/is-browser.mjs","../node_modules/framer-motion/dist/es/motion/features/definitions.mjs","../node_modules/framer-motion/dist/es/motion/utils/symbol.mjs","../node_modules/framer-motion/dist/es/motion/utils/use-motion-ref.mjs","../node_modules/framer-motion/dist/es/context/SwitchLayoutGroupContext.mjs","../node_modules/framer-motion/dist/es/utils/is-ref-object.mjs","../node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs","../node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs","../node_modules/framer-motion/dist/es/motion/index.mjs","../node_modules/framer-motion/dist/es/motion/features/load-features.mjs","../node_modules/framer-motion/dist/es/render/components/create-proxy.mjs","../node_modules/framer-motion/dist/es/motion/features/animation/index.mjs","../node_modules/framer-motion/dist/es/motion/features/animation/exit.mjs","../node_modules/framer-motion/dist/es/motion/features/animations.mjs","../node_modules/framer-motion/dist/es/events/event-info.mjs","../node_modules/framer-motion/dist/es/events/add-pointer-event.mjs","../node_modules/framer-motion/dist/es/utils/get-context-window.mjs","../node_modules/framer-motion/dist/es/utils/distance.mjs","../node_modules/framer-motion/dist/es/gestures/pan/PanSession.mjs","../node_modules/framer-motion/dist/es/gestures/drag/utils/constraints.mjs","../node_modules/framer-motion/dist/es/gestures/drag/VisualElementDragControls.mjs","../node_modules/framer-motion/dist/es/gestures/drag/index.mjs","../node_modules/framer-motion/dist/es/gestures/pan/index.mjs","../node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs","../node_modules/framer-motion/dist/es/components/AnimatePresence/use-presence.mjs","../node_modules/framer-motion/dist/es/motion/features/drag.mjs","../node_modules/framer-motion/dist/es/gestures/hover.mjs","../node_modules/framer-motion/dist/es/gestures/focus.mjs","../node_modules/framer-motion/dist/es/gestures/press.mjs","../node_modules/framer-motion/dist/es/motion/features/viewport/observers.mjs","../node_modules/framer-motion/dist/es/motion/features/viewport/index.mjs","../node_modules/framer-motion/dist/es/motion/features/gestures.mjs","../node_modules/framer-motion/dist/es/motion/features/layout.mjs","../node_modules/framer-motion/dist/es/render/components/motion/proxy.mjs","../node_modules/framer-motion/dist/es/render/components/motion/feature-bundle.mjs"],"sourcesContent":["/**\n * We keep these listed separately as we use the lowercase tag names as part\n * of the runtime bundle to detect SVG components\n */\nconst lowercaseSVGElements = [\"animate\", \"circle\", \"defs\", \"desc\", \"ellipse\", \"g\", \"image\", \"line\", \"filter\", \"marker\", \"mask\", \"metadata\", \"path\", \"pattern\", \"polygon\", \"polyline\", \"rect\", \"stop\", \"switch\", \"symbol\", \"svg\", \"text\", \"tspan\", \"use\", \"view\"];\nexport { lowercaseSVGElements };\n//# sourceMappingURL=lowercase-elements.mjs.map","import { lowercaseSVGElements } from '../../svg/lowercase-elements.mjs';\nfunction isSVGComponent(Component) {\n  if (\n  /**\n   * If it's not a string, it's a custom React component. Currently we only support\n   * HTML custom React components.\n   */\n  typeof Component !== \"string\" ||\n  /**\n   * If it contains a dash, the element is a custom HTML webcomponent.\n   */\n  Component.includes(\"-\")) {\n    return false;\n  } else if (\n  /**\n   * If it's in our list of lowercase SVG tags, it's an SVG component\n   */\n  lowercaseSVGElements.indexOf(Component) > -1 ||\n  /**\n   * If it contains a capital letter, it's an SVG component\n   */\n  /[A-Z]/.test(Component)) {\n    return true;\n  }\n  return false;\n}\nexport { isSVGComponent };\n//# sourceMappingURL=is-svg-component.mjs.map","import { SVGVisualElement, HTMLVisualElement } from 'motion-dom';\nimport { Fragment } from 'react';\nimport { isSVGComponent } from './utils/is-svg-component.mjs';\nconst createDomVisualElement = (Component, options) => {\n  var _options$isSVG;\n  /**\n   * Use explicit isSVG override if provided, otherwise auto-detect\n   */\n  const isSVG = (_options$isSVG = options.isSVG) !== null && _options$isSVG !== void 0 ? _options$isSVG : isSVGComponent(Component);\n  return isSVG ? new SVGVisualElement(options) : new HTMLVisualElement(options, {\n    allowProjection: Component !== Fragment\n  });\n};\nexport { createDomVisualElement };\n//# sourceMappingURL=create-visual-element.mjs.map","\"use client\";\n\nimport { createContext } from 'react';\nconst LayoutGroupContext = createContext({});\nexport { LayoutGroupContext };\n//# sourceMappingURL=LayoutGroupContext.mjs.map","\"use client\";\n\nimport { createContext } from 'react';\nconst LazyContext = createContext({\n  strict: false\n});\nexport { LazyContext };\n//# sourceMappingURL=LazyContext.mjs.map","\"use client\";\n\nimport { createContext } from 'react';\n\n/**\n * @public\n */\nconst MotionConfigContext = createContext({\n  transformPagePoint: p => p,\n  isStatic: false,\n  reducedMotion: \"never\"\n});\nexport { MotionConfigContext };\n//# sourceMappingURL=MotionConfigContext.mjs.map","\"use client\";\n\nimport { createContext } from 'react';\nconst MotionContext = /* @__PURE__ */createContext({});\nexport { MotionContext };\n//# sourceMappingURL=index.mjs.map","\"use client\";\n\nimport { useContext, useMemo } from 'react';\nimport { MotionContext } from './index.mjs';\nimport { getCurrentTreeVariants } from './utils.mjs';\nfunction useCreateMotionContext(props) {\n  const {\n    initial,\n    animate\n  } = getCurrentTreeVariants(props, useContext(MotionContext));\n  return useMemo(() => ({\n    initial,\n    animate\n  }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);\n}\nfunction variantLabelsAsDependency(prop) {\n  return Array.isArray(prop) ? prop.join(\" \") : prop;\n}\nexport { useCreateMotionContext };\n//# sourceMappingURL=create.mjs.map","import { isControllingVariants, isVariantLabel } from 'motion-dom';\nfunction getCurrentTreeVariants(props, context) {\n  if (isControllingVariants(props)) {\n    const {\n      initial,\n      animate\n    } = props;\n    return {\n      initial: initial === false || isVariantLabel(initial) ? initial : undefined,\n      animate: isVariantLabel(animate) ? animate : undefined\n    };\n  }\n  return props.inherit !== false ? context : {};\n}\nexport { getCurrentTreeVariants };\n//# sourceMappingURL=utils.mjs.map","const createHtmlRenderState = () => ({\n  style: {},\n  transform: {},\n  transformOrigin: {},\n  vars: {}\n});\nexport { createHtmlRenderState };\n//# sourceMappingURL=create-render-state.mjs.map","\"use client\";\n\nimport { isMotionValue, isForcedMotionValue, buildHTMLStyles } from 'motion-dom';\nimport { useMemo } from 'react';\nimport { createHtmlRenderState } from './utils/create-render-state.mjs';\nfunction copyRawValuesOnly(target, source, props) {\n  for (const key in source) {\n    if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {\n      target[key] = source[key];\n    }\n  }\n}\nfunction useInitialMotionValues(_ref, visualState) {\n  let {\n    transformTemplate\n  } = _ref;\n  return useMemo(() => {\n    const state = createHtmlRenderState();\n    buildHTMLStyles(state, visualState, transformTemplate);\n    return Object.assign({}, state.vars, state.style);\n  }, [visualState]);\n}\nfunction useStyle(props, visualState) {\n  const styleProp = props.style || {};\n  const style = {};\n  /**\n   * Copy non-Motion Values straight into style\n   */\n  copyRawValuesOnly(style, styleProp, props);\n  Object.assign(style, useInitialMotionValues(props, visualState));\n  return style;\n}\nfunction useHTMLProps(props, visualState) {\n  // The `any` isn't ideal but it is the type of createElement props argument\n  const htmlProps = {};\n  const style = useStyle(props, visualState);\n  if (props.drag && props.dragListener !== false) {\n    // Disable the ghost element when a user drags\n    htmlProps.draggable = false;\n    // Disable text selection\n    style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = \"none\";\n    // Disable scrolling on the draggable direction\n    style.touchAction = props.drag === true ? \"none\" : \"pan-\".concat(props.drag === \"x\" ? \"y\" : \"x\");\n  }\n  if (props.tabIndex === undefined && (props.onTap || props.onTapStart || props.whileTap)) {\n    htmlProps.tabIndex = 0;\n  }\n  htmlProps.style = style;\n  return htmlProps;\n}\nexport { copyRawValuesOnly, useHTMLProps };\n//# sourceMappingURL=use-props.mjs.map","import _objectSpread from \"/app/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { createHtmlRenderState } from '../../html/utils/create-render-state.mjs';\nconst createSvgRenderState = () => _objectSpread(_objectSpread({}, createHtmlRenderState()), {}, {\n  attrs: {}\n});\nexport { createSvgRenderState };\n//# sourceMappingURL=create-render-state.mjs.map","\"use client\";\n\nimport _objectSpread from \"/app/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { buildSVGAttrs, isSVGTag } from 'motion-dom';\nimport { useMemo } from 'react';\nimport { copyRawValuesOnly } from '../html/use-props.mjs';\nimport { createSvgRenderState } from './utils/create-render-state.mjs';\nfunction useSVGProps(props, visualState, _isStatic, Component) {\n  const visualProps = useMemo(() => {\n    const state = createSvgRenderState();\n    buildSVGAttrs(state, visualState, isSVGTag(Component), props.transformTemplate, props.style);\n    return _objectSpread(_objectSpread({}, state.attrs), {}, {\n      style: _objectSpread({}, state.style)\n    });\n  }, [visualState]);\n  if (props.style) {\n    const rawStyles = {};\n    copyRawValuesOnly(rawStyles, props.style, props);\n    visualProps.style = _objectSpread(_objectSpread({}, rawStyles), visualProps.style);\n  }\n  return visualProps;\n}\nexport { useSVGProps };\n//# sourceMappingURL=use-props.mjs.map","/**\n * A list of all valid MotionProps.\n *\n * @privateRemarks\n * This doesn't throw if a `MotionProp` name is missing - it should.\n */\nconst validMotionProps = new Set([\"animate\", \"exit\", \"variants\", \"initial\", \"style\", \"values\", \"variants\", \"transition\", \"transformTemplate\", \"custom\", \"inherit\", \"onBeforeLayoutMeasure\", \"onAnimationStart\", \"onAnimationComplete\", \"onUpdate\", \"onDragStart\", \"onDrag\", \"onDragEnd\", \"onMeasureDragConstraints\", \"onDirectionLock\", \"onDragTransitionEnd\", \"_dragX\", \"_dragY\", \"onHoverStart\", \"onHoverEnd\", \"onViewportEnter\", \"onViewportLeave\", \"globalTapTarget\", \"ignoreStrict\", \"viewport\"]);\n/**\n * Check whether a prop name is a valid `MotionProp` key.\n *\n * @param key - Name of the property to check\n * @returns `true` is key is a valid `MotionProp`.\n *\n * @public\n */\nfunction isValidMotionProp(key) {\n  return key.startsWith(\"while\") || key.startsWith(\"drag\") && key !== \"draggable\" || key.startsWith(\"layout\") || key.startsWith(\"onTap\") || key.startsWith(\"onPan\") || key.startsWith(\"onLayout\") || validMotionProps.has(key);\n}\nexport { isValidMotionProp };\n//# sourceMappingURL=valid-prop.mjs.map","import { isValidMotionProp } from '../../../motion/utils/valid-prop.mjs';\nlet shouldForward = key => !isValidMotionProp(key);\nfunction loadExternalIsValidProp(isValidProp) {\n  if (typeof isValidProp !== \"function\") return;\n  // Explicitly filter our events\n  shouldForward = key => key.startsWith(\"on\") ? !isValidMotionProp(key) : isValidProp(key);\n}\n/**\n * Emotion and Styled Components both allow users to pass through arbitrary props to their components\n * to dynamically generate CSS. They both use the `@emotion/is-prop-valid` package to determine which\n * of these should be passed to the underlying DOM node.\n *\n * However, when styling a Motion component `styled(motion.div)`, both packages pass through *all* props\n * as it's seen as an arbitrary component rather than a DOM node. Motion only allows arbitrary props\n * passed through the `custom` prop so it doesn't *need* the payload or computational overhead of\n * `@emotion/is-prop-valid`, however to fix this problem we need to use it.\n *\n * By making it an optionalDependency we can offer this functionality only in the situations where it's\n * actually required.\n */\ntry {\n  /**\n   * We attempt to import this package but require won't be defined in esm environments, in that case\n   * isPropValid will have to be provided via `MotionContext`. In a 6.0.0 this should probably be removed\n   * in favour of explicit injection.\n   */\n  loadExternalIsValidProp(require(\"@emotion/is-prop-valid\").default);\n} catch (_unused) {\n  // We don't need to actually do anything here - the fallback is the existing `isPropValid`.\n}\nfunction filterProps(props, isDom, forwardMotionProps) {\n  const filteredProps = {};\n  for (const key in props) {\n    /**\n     * values is considered a valid prop by Emotion, so if it's present\n     * this will be rendered out to the DOM unless explicitly filtered.\n     *\n     * We check the type as it could be used with the `feColorMatrix`\n     * element, which we support.\n     */\n    if (key === \"values\" && typeof props.values === \"object\") continue;\n    if (shouldForward(key) || forwardMotionProps === true && isValidMotionProp(key) || !isDom && !isValidMotionProp(key) ||\n    // If trying to use native HTML drag events, forward drag listeners\n    props[\"draggable\"] && key.startsWith(\"onDrag\")) {\n      filteredProps[key] = props[key];\n    }\n  }\n  return filteredProps;\n}\nexport { filterProps, loadExternalIsValidProp };\n//# sourceMappingURL=filter-props.mjs.map","\"use client\";\n\nimport _objectSpread from \"/app/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { isMotionValue } from 'motion-dom';\nimport { Fragment, useMemo, createElement } from 'react';\nimport { useHTMLProps } from '../html/use-props.mjs';\nimport { useSVGProps } from '../svg/use-props.mjs';\nimport { filterProps } from './utils/filter-props.mjs';\nimport { isSVGComponent } from './utils/is-svg-component.mjs';\nfunction useRender(Component, props, ref, _ref, isStatic) {\n  let {\n    latestValues\n  } = _ref;\n  let forwardMotionProps = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  let isSVG = arguments.length > 6 ? arguments[6] : undefined;\n  const useVisualProps = (isSVG !== null && isSVG !== void 0 ? isSVG : isSVGComponent(Component)) ? useSVGProps : useHTMLProps;\n  const visualProps = useVisualProps(props, latestValues, isStatic, Component);\n  const filteredProps = filterProps(props, typeof Component === \"string\", forwardMotionProps);\n  const elementProps = Component !== Fragment ? _objectSpread(_objectSpread(_objectSpread({}, filteredProps), visualProps), {}, {\n    ref\n  }) : {};\n  /**\n   * If component has been handed a motion value as its child,\n   * memoise its initial value and render that. Subsequent updates\n   * will be handled by the onChange handler\n   */\n  const {\n    children\n  } = props;\n  const renderedChildren = useMemo(() => isMotionValue(children) ? children.get() : children, [children]);\n  return createElement(Component, _objectSpread(_objectSpread({}, elementProps), {}, {\n    children: renderedChildren\n  }));\n}\nexport { useRender };\n//# sourceMappingURL=use-render.mjs.map","\"use client\";\n\nimport { createContext } from 'react';\n\n/**\n * @public\n */\nconst PresenceContext = /* @__PURE__ */createContext(null);\nexport { PresenceContext };\n//# sourceMappingURL=PresenceContext.mjs.map","\"use client\";\n\nimport _objectWithoutProperties from \"/app/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"transitionEnd\", \"transition\"];\nimport { resolveMotionValue, isControllingVariants, isVariantNode, isAnimationControls, resolveVariantFromProps } from 'motion-dom';\nimport { useContext } from 'react';\nimport { MotionContext } from '../../context/MotionContext/index.mjs';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nfunction makeState(_ref, props, context, presenceContext) {\n  let {\n    scrapeMotionValuesFromProps,\n    createRenderState\n  } = _ref;\n  const state = {\n    latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps),\n    renderState: createRenderState()\n  };\n  return state;\n}\nfunction makeLatestValues(props, context, presenceContext, scrapeMotionValues) {\n  const values = {};\n  const motionValues = scrapeMotionValues(props, {});\n  for (const key in motionValues) {\n    values[key] = resolveMotionValue(motionValues[key]);\n  }\n  let {\n    initial,\n    animate\n  } = props;\n  const isControllingVariants$1 = isControllingVariants(props);\n  const isVariantNode$1 = isVariantNode(props);\n  if (context && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== false) {\n    if (initial === undefined) initial = context.initial;\n    if (animate === undefined) animate = context.animate;\n  }\n  let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === false : false;\n  isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;\n  const variantToSet = isInitialAnimationBlocked ? animate : initial;\n  if (variantToSet && typeof variantToSet !== \"boolean\" && !isAnimationControls(variantToSet)) {\n    const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];\n    for (let i = 0; i < list.length; i++) {\n      const resolved = resolveVariantFromProps(props, list[i]);\n      if (resolved) {\n        const {\n            transitionEnd,\n            transition\n          } = resolved,\n          target = _objectWithoutProperties(resolved, _excluded);\n        for (const key in target) {\n          let valueTarget = target[key];\n          if (Array.isArray(valueTarget)) {\n            /**\n             * Take final keyframe if the initial animation is blocked because\n             * we want to initialise at the end of that blocked animation.\n             */\n            const index = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;\n            valueTarget = valueTarget[index];\n          }\n          if (valueTarget !== null) {\n            values[key] = valueTarget;\n          }\n        }\n        for (const key in transitionEnd) {\n          values[key] = transitionEnd[key];\n        }\n      }\n    }\n  }\n  return values;\n}\nconst makeUseVisualState = config => (props, isStatic) => {\n  const context = useContext(MotionContext);\n  const presenceContext = useContext(PresenceContext);\n  const make = () => makeState(config, props, context, presenceContext);\n  return isStatic ? make() : useConstant(make);\n};\nexport { makeUseVisualState };\n//# sourceMappingURL=use-visual-state.mjs.map","\"use client\";\n\nimport { useRef } from 'react';\n\n/**\n * Creates a constant value over the lifecycle of a component.\n *\n * Even if `useMemo` is provided an empty array as its final argument, it doesn't offer\n * a guarantee that it won't re-run for performance reasons later on. By using `useConstant`\n * you can ensure that initialisers don't execute twice or more.\n */\nfunction useConstant(init) {\n  const ref = useRef(null);\n  if (ref.current === null) {\n    ref.current = init();\n  }\n  return ref.current;\n}\nexport { useConstant };\n//# sourceMappingURL=use-constant.mjs.map","\"use client\";\n\nimport { scrapeHTMLMotionValuesFromProps } from 'motion-dom';\nimport { makeUseVisualState } from '../../motion/utils/use-visual-state.mjs';\nimport { createHtmlRenderState } from './utils/create-render-state.mjs';\nconst useHTMLVisualState = /*@__PURE__*/makeUseVisualState({\n  scrapeMotionValuesFromProps: scrapeHTMLMotionValuesFromProps,\n  createRenderState: createHtmlRenderState\n});\nexport { useHTMLVisualState };\n//# sourceMappingURL=use-html-visual-state.mjs.map","\"use client\";\n\nimport { scrapeSVGMotionValuesFromProps } from 'motion-dom';\nimport { makeUseVisualState } from '../../motion/utils/use-visual-state.mjs';\nimport { createSvgRenderState } from './utils/create-render-state.mjs';\nconst useSVGVisualState = /*@__PURE__*/makeUseVisualState({\n  scrapeMotionValuesFromProps: scrapeSVGMotionValuesFromProps,\n  createRenderState: createSvgRenderState\n});\nexport { useSVGVisualState };\n//# sourceMappingURL=use-svg-visual-state.mjs.map","const isBrowser = typeof window !== \"undefined\";\nexport { isBrowser };\n//# sourceMappingURL=is-browser.mjs.map","import { getFeatureDefinitions, setFeatureDefinitions } from 'motion-dom';\nconst featureProps = {\n  animation: [\"animate\", \"variants\", \"whileHover\", \"whileTap\", \"exit\", \"whileInView\", \"whileFocus\", \"whileDrag\"],\n  exit: [\"exit\"],\n  drag: [\"drag\", \"dragControls\"],\n  focus: [\"whileFocus\"],\n  hover: [\"whileHover\", \"onHoverStart\", \"onHoverEnd\"],\n  tap: [\"whileTap\", \"onTap\", \"onTapStart\", \"onTapCancel\"],\n  pan: [\"onPan\", \"onPanStart\", \"onPanSessionStart\", \"onPanEnd\"],\n  inView: [\"whileInView\", \"onViewportEnter\", \"onViewportLeave\"],\n  layout: [\"layout\", \"layoutId\"]\n};\nlet isInitialized = false;\n/**\n * Initialize feature definitions with isEnabled checks.\n * This must be called before any motion components are rendered.\n */\nfunction initFeatureDefinitions() {\n  if (isInitialized) return;\n  const initialFeatureDefinitions = {};\n  for (const key in featureProps) {\n    initialFeatureDefinitions[key] = {\n      isEnabled: props => featureProps[key].some(name => !!props[name])\n    };\n  }\n  setFeatureDefinitions(initialFeatureDefinitions);\n  isInitialized = true;\n}\n/**\n * Get the current feature definitions, initializing if needed.\n */\nfunction getInitializedFeatureDefinitions() {\n  initFeatureDefinitions();\n  return getFeatureDefinitions();\n}\nexport { getInitializedFeatureDefinitions, initFeatureDefinitions };\n//# sourceMappingURL=definitions.mjs.map","const motionComponentSymbol = Symbol.for(\"motionComponentSymbol\");\nexport { motionComponentSymbol };\n//# sourceMappingURL=symbol.mjs.map","\"use client\";\n\nimport { useRef, useInsertionEffect, useCallback } from 'react';\n\n/**\n * Creates a ref function that, when called, hydrates the provided\n * external ref and VisualElement.\n */\nfunction useMotionRef(visualState, visualElement, externalRef) {\n  /**\n   * Store externalRef in a ref to avoid including it in the useCallback\n   * dependency array. Including externalRef in dependencies causes issues\n   * with libraries like Radix UI that create new callback refs on each render\n   * when using asChild - this would cause the callback to be recreated,\n   * triggering element remounts and breaking AnimatePresence exit animations.\n   */\n  const externalRefContainer = useRef(externalRef);\n  useInsertionEffect(() => {\n    externalRefContainer.current = externalRef;\n  });\n  // Store cleanup function returned by callback refs (React 19 feature)\n  const refCleanup = useRef(null);\n  return useCallback(instance => {\n    if (instance) {\n      var _visualState$onMount;\n      (_visualState$onMount = visualState.onMount) === null || _visualState$onMount === void 0 || _visualState$onMount.call(visualState, instance);\n    }\n    if (visualElement) {\n      instance ? visualElement.mount(instance) : visualElement.unmount();\n    }\n    const ref = externalRefContainer.current;\n    if (typeof ref === \"function\") {\n      if (instance) {\n        const cleanup = ref(instance);\n        if (typeof cleanup === \"function\") {\n          refCleanup.current = cleanup;\n        }\n      } else if (refCleanup.current) {\n        refCleanup.current();\n        refCleanup.current = null;\n      } else {\n        ref(instance);\n      }\n    } else if (ref) {\n      ref.current = instance;\n    }\n  }, [visualElement]);\n}\nexport { useMotionRef };\n//# sourceMappingURL=use-motion-ref.mjs.map","\"use client\";\n\nimport { createContext } from 'react';\n\n/**\n * Internal, exported only for usage in Framer\n */\nconst SwitchLayoutGroupContext = createContext({});\nexport { SwitchLayoutGroupContext };\n//# sourceMappingURL=SwitchLayoutGroupContext.mjs.map","function isRefObject(ref) {\n  return ref && typeof ref === \"object\" && Object.prototype.hasOwnProperty.call(ref, \"current\");\n}\nexport { isRefObject };\n//# sourceMappingURL=is-ref-object.mjs.map","\"use client\";\n\nimport { useLayoutEffect, useEffect } from 'react';\nimport { isBrowser } from './is-browser.mjs';\nconst useIsomorphicLayoutEffect = isBrowser ? useLayoutEffect : useEffect;\nexport { useIsomorphicLayoutEffect };\n//# sourceMappingURL=use-isomorphic-effect.mjs.map","\"use client\";\n\nimport { optimizedAppearDataAttribute } from 'motion-dom';\nimport { useContext, useRef, useInsertionEffect, useEffect } from 'react';\nimport { LazyContext } from '../../context/LazyContext.mjs';\nimport { MotionConfigContext } from '../../context/MotionConfigContext.mjs';\nimport { MotionContext } from '../../context/MotionContext/index.mjs';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\nimport { SwitchLayoutGroupContext } from '../../context/SwitchLayoutGroupContext.mjs';\nimport { isRefObject } from '../../utils/is-ref-object.mjs';\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\nfunction useVisualElement(Component, visualState, props, createVisualElement, ProjectionNodeConstructor, isSVG) {\n  var _window$MotionHandoff, _window, _window$MotionHasOpti, _window2;\n  const {\n    visualElement: parent\n  } = useContext(MotionContext);\n  const lazyContext = useContext(LazyContext);\n  const presenceContext = useContext(PresenceContext);\n  const reducedMotionConfig = useContext(MotionConfigContext).reducedMotion;\n  const visualElementRef = useRef(null);\n  /**\n   * If we haven't preloaded a renderer, check to see if we have one lazy-loaded\n   */\n  createVisualElement = createVisualElement || lazyContext.renderer;\n  if (!visualElementRef.current && createVisualElement) {\n    visualElementRef.current = createVisualElement(Component, {\n      visualState,\n      parent,\n      props,\n      presenceContext,\n      blockInitialAnimation: presenceContext ? presenceContext.initial === false : false,\n      reducedMotionConfig,\n      isSVG\n    });\n  }\n  const visualElement = visualElementRef.current;\n  /**\n   * Load Motion gesture and animation features. These are rendered as renderless\n   * components so each feature can optionally make use of React lifecycle methods.\n   */\n  const initialLayoutGroupConfig = useContext(SwitchLayoutGroupContext);\n  if (visualElement && !visualElement.projection && ProjectionNodeConstructor && (visualElement.type === \"html\" || visualElement.type === \"svg\")) {\n    createProjectionNode(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);\n  }\n  const isMounted = useRef(false);\n  useInsertionEffect(() => {\n    /**\n     * Check the component has already mounted before calling\n     * `update` unnecessarily. This ensures we skip the initial update.\n     */\n    if (visualElement && isMounted.current) {\n      visualElement.update(props, presenceContext);\n    }\n  });\n  /**\n   * Cache this value as we want to know whether HandoffAppearAnimations\n   * was present on initial render - it will be deleted after this.\n   */\n  const optimisedAppearId = props[optimizedAppearDataAttribute];\n  const wantsHandoff = useRef(Boolean(optimisedAppearId) && !((_window$MotionHandoff = (_window = window).MotionHandoffIsComplete) !== null && _window$MotionHandoff !== void 0 && _window$MotionHandoff.call(_window, optimisedAppearId)) && ((_window$MotionHasOpti = (_window2 = window).MotionHasOptimisedAnimation) === null || _window$MotionHasOpti === void 0 ? void 0 : _window$MotionHasOpti.call(_window2, optimisedAppearId)));\n  useIsomorphicLayoutEffect(() => {\n    if (!visualElement) return;\n    isMounted.current = true;\n    window.MotionIsMounted = true;\n    visualElement.updateFeatures();\n    visualElement.scheduleRenderMicrotask();\n    /**\n     * Ideally this function would always run in a useEffect.\n     *\n     * However, if we have optimised appear animations to handoff from,\n     * it needs to happen synchronously to ensure there's no flash of\n     * incorrect styles in the event of a hydration error.\n     *\n     * So if we detect a situtation where optimised appear animations\n     * are running, we use useLayoutEffect to trigger animations.\n     */\n    if (wantsHandoff.current && visualElement.animationState) {\n      visualElement.animationState.animateChanges();\n    }\n  });\n  useEffect(() => {\n    if (!visualElement) return;\n    if (!wantsHandoff.current && visualElement.animationState) {\n      visualElement.animationState.animateChanges();\n    }\n    if (wantsHandoff.current) {\n      // This ensures all future calls to animateChanges() in this component will run in useEffect\n      queueMicrotask(() => {\n        var _window$MotionHandoff2, _window3;\n        (_window$MotionHandoff2 = (_window3 = window).MotionHandoffMarkAsComplete) === null || _window$MotionHandoff2 === void 0 || _window$MotionHandoff2.call(_window3, optimisedAppearId);\n      });\n      wantsHandoff.current = false;\n    }\n    /**\n     * Now we've finished triggering animations for this element we\n     * can wipe the enteringChildren set for the next render.\n     */\n    visualElement.enteringChildren = undefined;\n  });\n  return visualElement;\n}\nfunction createProjectionNode(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {\n  const {\n    layoutId,\n    layout,\n    drag,\n    dragConstraints,\n    layoutScroll,\n    layoutRoot,\n    layoutCrossfade\n  } = props;\n  visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props[\"data-framer-portal-id\"] ? undefined : getClosestProjectingNode(visualElement.parent));\n  visualElement.projection.setOptions({\n    layoutId,\n    layout,\n    alwaysMeasureLayout: Boolean(drag) || dragConstraints && isRefObject(dragConstraints),\n    visualElement,\n    /**\n     * TODO: Update options in an effect. This could be tricky as it'll be too late\n     * to update by the time layout animations run.\n     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,\n     * ensuring it gets called if there's no potential layout animations.\n     *\n     */\n    animationType: typeof layout === \"string\" ? layout : \"both\",\n    initialPromotionConfig,\n    crossfade: layoutCrossfade,\n    layoutScroll,\n    layoutRoot\n  });\n}\nfunction getClosestProjectingNode(visualElement) {\n  if (!visualElement) return undefined;\n  return visualElement.options.allowProjection !== false ? visualElement.projection : getClosestProjectingNode(visualElement.parent);\n}\nexport { useVisualElement };\n//# sourceMappingURL=use-visual-element.mjs.map","\"use client\";\n\nimport _objectSpread from \"/app/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { jsxs, jsx } from 'react/jsx-runtime';\nimport { warning, invariant } from 'motion-utils';\nimport { forwardRef, useContext } from 'react';\nimport { LayoutGroupContext } from '../context/LayoutGroupContext.mjs';\nimport { LazyContext } from '../context/LazyContext.mjs';\nimport { MotionConfigContext } from '../context/MotionConfigContext.mjs';\nimport { MotionContext } from '../context/MotionContext/index.mjs';\nimport { useCreateMotionContext } from '../context/MotionContext/create.mjs';\nimport { useRender } from '../render/dom/use-render.mjs';\nimport { isSVGComponent } from '../render/dom/utils/is-svg-component.mjs';\nimport { useHTMLVisualState } from '../render/html/use-html-visual-state.mjs';\nimport { useSVGVisualState } from '../render/svg/use-svg-visual-state.mjs';\nimport { isBrowser } from '../utils/is-browser.mjs';\nimport { getInitializedFeatureDefinitions } from './features/definitions.mjs';\nimport { loadFeatures } from './features/load-features.mjs';\nimport { motionComponentSymbol } from './utils/symbol.mjs';\nimport { useMotionRef } from './utils/use-motion-ref.mjs';\nimport { useVisualElement } from './utils/use-visual-element.mjs';\n\n/**\n * Create a `motion` component.\n *\n * This function accepts a Component argument, which can be either a string (ie \"div\"\n * for `motion.div`), or an actual React component.\n *\n * Alongside this is a config option which provides a way of rendering the provided\n * component \"offline\", or outside the React render cycle.\n */\nfunction createMotionComponent(Component) {\n  var _ref, _Component$displayNam;\n  let {\n    forwardMotionProps = false,\n    type\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let preloadedFeatures = arguments.length > 2 ? arguments[2] : undefined;\n  let createVisualElement = arguments.length > 3 ? arguments[3] : undefined;\n  preloadedFeatures && loadFeatures(preloadedFeatures);\n  /**\n   * Determine whether to use SVG or HTML rendering based on:\n   * 1. Explicit `type` option (highest priority)\n   * 2. Auto-detection via `isSVGComponent`\n   */\n  const isSVG = type ? type === \"svg\" : isSVGComponent(Component);\n  const useVisualState = isSVG ? useSVGVisualState : useHTMLVisualState;\n  function MotionDOMComponent(props, externalRef) {\n    /**\n     * If we need to measure the element we load this functionality in a\n     * separate class component in order to gain access to getSnapshotBeforeUpdate.\n     */\n    let MeasureLayout;\n    const configAndProps = _objectSpread(_objectSpread(_objectSpread({}, useContext(MotionConfigContext)), props), {}, {\n      layoutId: useLayoutId(props)\n    });\n    const {\n      isStatic\n    } = configAndProps;\n    const context = useCreateMotionContext(props);\n    const visualState = useVisualState(props, isStatic);\n    if (!isStatic && isBrowser) {\n      useStrictMode(configAndProps, preloadedFeatures);\n      const layoutProjection = getProjectionFunctionality(configAndProps);\n      MeasureLayout = layoutProjection.MeasureLayout;\n      /**\n       * Create a VisualElement for this component. A VisualElement provides a common\n       * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\n       * providing a way of rendering to these APIs outside of the React render loop\n       * for more performant animations and interactions\n       */\n      context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode, isSVG);\n    }\n    /**\n     * The mount order and hierarchy is specific to ensure our element ref\n     * is hydrated by the time features fire their effects.\n     */\n    return jsxs(MotionContext.Provider, {\n      value: context,\n      children: [MeasureLayout && context.visualElement ? jsx(MeasureLayout, _objectSpread({\n        visualElement: context.visualElement\n      }, configAndProps)) : null, useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, forwardMotionProps, isSVG)]\n    });\n  }\n  MotionDOMComponent.displayName = \"motion.\".concat(typeof Component === \"string\" ? Component : \"create(\".concat((_ref = (_Component$displayNam = Component.displayName) !== null && _Component$displayNam !== void 0 ? _Component$displayNam : Component.name) !== null && _ref !== void 0 ? _ref : \"\", \")\"));\n  const ForwardRefMotionComponent = forwardRef(MotionDOMComponent);\n  ForwardRefMotionComponent[motionComponentSymbol] = Component;\n  return ForwardRefMotionComponent;\n}\nfunction useLayoutId(_ref2) {\n  let {\n    layoutId\n  } = _ref2;\n  const layoutGroupId = useContext(LayoutGroupContext).id;\n  return layoutGroupId && layoutId !== undefined ? layoutGroupId + \"-\" + layoutId : layoutId;\n}\nfunction useStrictMode(configAndProps, preloadedFeatures) {\n  const isStrict = useContext(LazyContext).strict;\n  /**\n   * If we're in development mode, check to make sure we're not rendering a motion component\n   * as a child of LazyMotion, as this will break the file-size benefits of using it.\n   */\n  if (process.env.NODE_ENV !== \"production\" && preloadedFeatures && isStrict) {\n    const strictMessage = \"You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.\";\n    configAndProps.ignoreStrict ? warning(false, strictMessage, \"lazy-strict-mode\") : invariant(false, strictMessage, \"lazy-strict-mode\");\n  }\n}\nfunction getProjectionFunctionality(props) {\n  const featureDefinitions = getInitializedFeatureDefinitions();\n  const {\n    drag,\n    layout\n  } = featureDefinitions;\n  if (!drag && !layout) return {};\n  const combined = _objectSpread(_objectSpread({}, drag), layout);\n  return {\n    MeasureLayout: drag !== null && drag !== void 0 && drag.isEnabled(props) || layout !== null && layout !== void 0 && layout.isEnabled(props) ? combined.MeasureLayout : undefined,\n    ProjectionNode: combined.ProjectionNode\n  };\n}\nexport { createMotionComponent };\n//# sourceMappingURL=index.mjs.map","import _objectSpread from \"/app/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { setFeatureDefinitions } from 'motion-dom';\nimport { getInitializedFeatureDefinitions } from './definitions.mjs';\nfunction loadFeatures(features) {\n  const featureDefinitions = getInitializedFeatureDefinitions();\n  for (const key in features) {\n    featureDefinitions[key] = _objectSpread(_objectSpread({}, featureDefinitions[key]), features[key]);\n  }\n  setFeatureDefinitions(featureDefinitions);\n}\nexport { loadFeatures };\n//# sourceMappingURL=load-features.mjs.map","import { warnOnce } from 'motion-utils';\nimport { createMotionComponent } from '../../motion/index.mjs';\nfunction createMotionProxy(preloadedFeatures, createVisualElement) {\n  if (typeof Proxy === \"undefined\") {\n    return createMotionComponent;\n  }\n  /**\n   * A cache of generated `motion` components, e.g `motion.div`, `motion.input` etc.\n   * Rather than generating them anew every render.\n   */\n  const componentCache = new Map();\n  const factory = (Component, options) => {\n    return createMotionComponent(Component, options, preloadedFeatures, createVisualElement);\n  };\n  /**\n   * Support for deprecated`motion(Component)` pattern\n   */\n  const deprecatedFactoryFunction = (Component, options) => {\n    if (process.env.NODE_ENV !== \"production\") {\n      warnOnce(false, \"motion() is deprecated. Use motion.create() instead.\");\n    }\n    return factory(Component, options);\n  };\n  return new Proxy(deprecatedFactoryFunction, {\n    /**\n     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.\n     * The prop name is passed through as `key` and we can use that to generate a `motion`\n     * DOM component with that name.\n     */\n    get: (_target, key) => {\n      if (key === \"create\") return factory;\n      /**\n       * If this element doesn't exist in the component cache, create it and cache.\n       */\n      if (!componentCache.has(key)) {\n        componentCache.set(key, createMotionComponent(key, undefined, preloadedFeatures, createVisualElement));\n      }\n      return componentCache.get(key);\n    }\n  });\n}\nexport { createMotionProxy };\n//# sourceMappingURL=create-proxy.mjs.map","import { Feature, createAnimationState, isAnimationControls } from 'motion-dom';\nclass AnimationFeature extends Feature {\n  /**\n   * We dynamically generate the AnimationState manager as it contains a reference\n   * to the underlying animation library. We only want to load that if we load this,\n   * so people can optionally code split it out using the `m` component.\n   */\n  constructor(node) {\n    super(node);\n    node.animationState || (node.animationState = createAnimationState(node));\n  }\n  updateAnimationControlsSubscription() {\n    const {\n      animate\n    } = this.node.getProps();\n    if (isAnimationControls(animate)) {\n      this.unmountControls = animate.subscribe(this.node);\n    }\n  }\n  /**\n   * Subscribe any provided AnimationControls to the component's VisualElement\n   */\n  mount() {\n    this.updateAnimationControlsSubscription();\n  }\n  update() {\n    const {\n      animate\n    } = this.node.getProps();\n    const {\n      animate: prevAnimate\n    } = this.node.prevProps || {};\n    if (animate !== prevAnimate) {\n      this.updateAnimationControlsSubscription();\n    }\n  }\n  unmount() {\n    var _this$unmountControls;\n    this.node.animationState.reset();\n    (_this$unmountControls = this.unmountControls) === null || _this$unmountControls === void 0 || _this$unmountControls.call(this);\n  }\n}\nexport { AnimationFeature };\n//# sourceMappingURL=index.mjs.map","import { Feature } from 'motion-dom';\nlet id = 0;\nclass ExitAnimationFeature extends Feature {\n  constructor() {\n    super(...arguments);\n    this.id = id++;\n  }\n  update() {\n    if (!this.node.presenceContext) return;\n    const {\n      isPresent,\n      onExitComplete\n    } = this.node.presenceContext;\n    const {\n      isPresent: prevIsPresent\n    } = this.node.prevPresenceContext || {};\n    if (!this.node.animationState || isPresent === prevIsPresent) {\n      return;\n    }\n    const exitAnimation = this.node.animationState.setActive(\"exit\", !isPresent);\n    if (onExitComplete && !isPresent) {\n      exitAnimation.then(() => {\n        onExitComplete(this.id);\n      });\n    }\n  }\n  mount() {\n    const {\n      register,\n      onExitComplete\n    } = this.node.presenceContext || {};\n    if (onExitComplete) {\n      onExitComplete(this.id);\n    }\n    if (register) {\n      this.unmount = register(this.id);\n    }\n  }\n  unmount() {}\n}\nexport { ExitAnimationFeature };\n//# sourceMappingURL=exit.mjs.map","import { AnimationFeature } from './animation/index.mjs';\nimport { ExitAnimationFeature } from './animation/exit.mjs';\nconst animations = {\n  animation: {\n    Feature: AnimationFeature\n  },\n  exit: {\n    Feature: ExitAnimationFeature\n  }\n};\nexport { animations };\n//# sourceMappingURL=animations.mjs.map","import { isPrimaryPointer } from 'motion-dom';\nfunction extractEventInfo(event) {\n  return {\n    point: {\n      x: event.pageX,\n      y: event.pageY\n    }\n  };\n}\nconst addPointerInfo = handler => {\n  return event => isPrimaryPointer(event) && handler(event, extractEventInfo(event));\n};\nexport { addPointerInfo, extractEventInfo };\n//# sourceMappingURL=event-info.mjs.map","import { addDomEvent } from 'motion-dom';\nimport { addPointerInfo } from './event-info.mjs';\nfunction addPointerEvent(target, eventName, handler, options) {\n  return addDomEvent(target, eventName, addPointerInfo(handler), options);\n}\nexport { addPointerEvent };\n//# sourceMappingURL=add-pointer-event.mjs.map","// Fixes https://github.com/motiondivision/motion/issues/2270\nconst getContextWindow = _ref => {\n  let {\n    current\n  } = _ref;\n  return current ? current.ownerDocument.defaultView : null;\n};\nexport { getContextWindow };\n//# sourceMappingURL=get-context-window.mjs.map","const distance = (a, b) => Math.abs(a - b);\nfunction distance2D(a, b) {\n  // Multi-dimensional\n  const xDelta = distance(a.x, b.x);\n  const yDelta = distance(a.y, b.y);\n  return Math.sqrt(xDelta ** 2 + yDelta ** 2);\n}\nexport { distance, distance2D };\n//# sourceMappingURL=distance.mjs.map","import _objectSpread from \"/app/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { frame, isPrimaryPointer, cancelFrame, frameData } from 'motion-dom';\nimport { pipe, secondsToMilliseconds, millisecondsToSeconds } from 'motion-utils';\nimport { addPointerEvent } from '../../events/add-pointer-event.mjs';\nimport { extractEventInfo } from '../../events/event-info.mjs';\nimport { distance2D } from '../../utils/distance.mjs';\nconst overflowStyles = /*#__PURE__*/new Set([\"auto\", \"scroll\"]);\n/**\n * @internal\n */\nclass PanSession {\n  constructor(event, handlers) {\n    let {\n      transformPagePoint,\n      contextWindow = window,\n      dragSnapToOrigin = false,\n      distanceThreshold = 3,\n      element\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    /**\n     * @internal\n     */\n    this.startEvent = null;\n    /**\n     * @internal\n     */\n    this.lastMoveEvent = null;\n    /**\n     * @internal\n     */\n    this.lastMoveEventInfo = null;\n    /**\n     * @internal\n     */\n    this.handlers = {};\n    /**\n     * @internal\n     */\n    this.contextWindow = window;\n    /**\n     * Scroll positions of scrollable ancestors and window.\n     * @internal\n     */\n    this.scrollPositions = new Map();\n    /**\n     * Cleanup function for scroll listeners.\n     * @internal\n     */\n    this.removeScrollListeners = null;\n    this.onElementScroll = event => {\n      this.handleScroll(event.target);\n    };\n    this.onWindowScroll = () => {\n      this.handleScroll(window);\n    };\n    this.updatePoint = () => {\n      if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;\n      const info = getPanInfo(this.lastMoveEventInfo, this.history);\n      const isPanStarted = this.startEvent !== null;\n      // Only start panning if the offset is larger than 3 pixels. If we make it\n      // any larger than this we'll want to reset the pointer history\n      // on the first update to avoid visual snapping to the cursor.\n      const isDistancePastThreshold = distance2D(info.offset, {\n        x: 0,\n        y: 0\n      }) >= this.distanceThreshold;\n      if (!isPanStarted && !isDistancePastThreshold) return;\n      const {\n        point\n      } = info;\n      const {\n        timestamp\n      } = frameData;\n      this.history.push(_objectSpread(_objectSpread({}, point), {}, {\n        timestamp\n      }));\n      const {\n        onStart,\n        onMove\n      } = this.handlers;\n      if (!isPanStarted) {\n        onStart && onStart(this.lastMoveEvent, info);\n        this.startEvent = this.lastMoveEvent;\n      }\n      onMove && onMove(this.lastMoveEvent, info);\n    };\n    this.handlePointerMove = (event, info) => {\n      this.lastMoveEvent = event;\n      this.lastMoveEventInfo = transformPoint(info, this.transformPagePoint);\n      // Throttle mouse move event to once per frame\n      frame.update(this.updatePoint, true);\n    };\n    this.handlePointerUp = (event, info) => {\n      this.end();\n      const {\n        onEnd,\n        onSessionEnd,\n        resumeAnimation\n      } = this.handlers;\n      // Resume animation if dragSnapToOrigin is set OR if no drag started (user just clicked)\n      // This ensures constraint animations continue when interrupted by a click\n      if (this.dragSnapToOrigin || !this.startEvent) {\n        resumeAnimation && resumeAnimation();\n      }\n      if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;\n      const panInfo = getPanInfo(event.type === \"pointercancel\" ? this.lastMoveEventInfo : transformPoint(info, this.transformPagePoint), this.history);\n      if (this.startEvent && onEnd) {\n        onEnd(event, panInfo);\n      }\n      onSessionEnd && onSessionEnd(event, panInfo);\n    };\n    // If we have more than one touch, don't start detecting this gesture\n    if (!isPrimaryPointer(event)) return;\n    this.dragSnapToOrigin = dragSnapToOrigin;\n    this.handlers = handlers;\n    this.transformPagePoint = transformPagePoint;\n    this.distanceThreshold = distanceThreshold;\n    this.contextWindow = contextWindow || window;\n    const info = extractEventInfo(event);\n    const initialInfo = transformPoint(info, this.transformPagePoint);\n    const {\n      point\n    } = initialInfo;\n    const {\n      timestamp\n    } = frameData;\n    this.history = [_objectSpread(_objectSpread({}, point), {}, {\n      timestamp\n    })];\n    const {\n      onSessionStart\n    } = handlers;\n    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));\n    this.removeListeners = pipe(addPointerEvent(this.contextWindow, \"pointermove\", this.handlePointerMove), addPointerEvent(this.contextWindow, \"pointerup\", this.handlePointerUp), addPointerEvent(this.contextWindow, \"pointercancel\", this.handlePointerUp));\n    // Start scroll tracking if element provided\n    if (element) {\n      this.startScrollTracking(element);\n    }\n  }\n  /**\n   * Start tracking scroll on ancestors and window.\n   */\n  startScrollTracking(element) {\n    // Store initial scroll positions for scrollable ancestors\n    let current = element.parentElement;\n    while (current) {\n      const style = getComputedStyle(current);\n      if (overflowStyles.has(style.overflowX) || overflowStyles.has(style.overflowY)) {\n        this.scrollPositions.set(current, {\n          x: current.scrollLeft,\n          y: current.scrollTop\n        });\n      }\n      current = current.parentElement;\n    }\n    // Track window scroll\n    this.scrollPositions.set(window, {\n      x: window.scrollX,\n      y: window.scrollY\n    });\n    // Capture listener catches element scroll events as they bubble\n    window.addEventListener(\"scroll\", this.onElementScroll, {\n      capture: true,\n      passive: true\n    });\n    // Direct window scroll listener (window scroll doesn't bubble)\n    window.addEventListener(\"scroll\", this.onWindowScroll, {\n      passive: true\n    });\n    this.removeScrollListeners = () => {\n      window.removeEventListener(\"scroll\", this.onElementScroll, {\n        capture: true\n      });\n      window.removeEventListener(\"scroll\", this.onWindowScroll);\n    };\n  }\n  /**\n   * Handle scroll compensation during drag.\n   *\n   * For element scroll: adjusts history origin since pageX/pageY doesn't change.\n   * For window scroll: adjusts lastMoveEventInfo since pageX/pageY would change.\n   */\n  handleScroll(target) {\n    const initial = this.scrollPositions.get(target);\n    if (!initial) return;\n    const isWindow = target === window;\n    const current = isWindow ? {\n      x: window.scrollX,\n      y: window.scrollY\n    } : {\n      x: target.scrollLeft,\n      y: target.scrollTop\n    };\n    const delta = {\n      x: current.x - initial.x,\n      y: current.y - initial.y\n    };\n    if (delta.x === 0 && delta.y === 0) return;\n    if (isWindow) {\n      // Window scroll: pageX/pageY changes, so update lastMoveEventInfo\n      if (this.lastMoveEventInfo) {\n        this.lastMoveEventInfo.point.x += delta.x;\n        this.lastMoveEventInfo.point.y += delta.y;\n      }\n    } else {\n      // Element scroll: pageX/pageY unchanged, so adjust history origin\n      if (this.history.length > 0) {\n        this.history[0].x -= delta.x;\n        this.history[0].y -= delta.y;\n      }\n    }\n    this.scrollPositions.set(target, current);\n    frame.update(this.updatePoint, true);\n  }\n  updateHandlers(handlers) {\n    this.handlers = handlers;\n  }\n  end() {\n    this.removeListeners && this.removeListeners();\n    this.removeScrollListeners && this.removeScrollListeners();\n    this.scrollPositions.clear();\n    cancelFrame(this.updatePoint);\n  }\n}\nfunction transformPoint(info, transformPagePoint) {\n  return transformPagePoint ? {\n    point: transformPagePoint(info.point)\n  } : info;\n}\nfunction subtractPoint(a, b) {\n  return {\n    x: a.x - b.x,\n    y: a.y - b.y\n  };\n}\nfunction getPanInfo(_ref, history) {\n  let {\n    point\n  } = _ref;\n  return {\n    point,\n    delta: subtractPoint(point, lastDevicePoint(history)),\n    offset: subtractPoint(point, startDevicePoint(history)),\n    velocity: getVelocity(history, 0.1)\n  };\n}\nfunction startDevicePoint(history) {\n  return history[0];\n}\nfunction lastDevicePoint(history) {\n  return history[history.length - 1];\n}\nfunction getVelocity(history, timeDelta) {\n  if (history.length < 2) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n  let i = history.length - 1;\n  let timestampedPoint = null;\n  const lastPoint = lastDevicePoint(history);\n  while (i >= 0) {\n    timestampedPoint = history[i];\n    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {\n      break;\n    }\n    i--;\n  }\n  if (!timestampedPoint) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n  const time = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);\n  if (time === 0) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n  const currentVelocity = {\n    x: (lastPoint.x - timestampedPoint.x) / time,\n    y: (lastPoint.y - timestampedPoint.y) / time\n  };\n  if (currentVelocity.x === Infinity) {\n    currentVelocity.x = 0;\n  }\n  if (currentVelocity.y === Infinity) {\n    currentVelocity.y = 0;\n  }\n  return currentVelocity;\n}\nexport { PanSession };\n//# sourceMappingURL=PanSession.mjs.map","import { mixNumber, calcLength } from 'motion-dom';\nimport { progress, clamp } from 'motion-utils';\n\n/**\n * Apply constraints to a point. These constraints are both physical along an\n * axis, and an elastic factor that determines how much to constrain the point\n * by if it does lie outside the defined parameters.\n */\nfunction applyConstraints(point, _ref, elastic) {\n  let {\n    min,\n    max\n  } = _ref;\n  if (min !== undefined && point < min) {\n    // If we have a min point defined, and this is outside of that, constrain\n    point = elastic ? mixNumber(min, point, elastic.min) : Math.max(point, min);\n  } else if (max !== undefined && point > max) {\n    // If we have a max point defined, and this is outside of that, constrain\n    point = elastic ? mixNumber(max, point, elastic.max) : Math.min(point, max);\n  }\n  return point;\n}\n/**\n * Calculate constraints in terms of the viewport when defined relatively to the\n * measured axis. This is measured from the nearest edge, so a max constraint of 200\n * on an axis with a max value of 300 would return a constraint of 500 - axis length\n */\nfunction calcRelativeAxisConstraints(axis, min, max) {\n  return {\n    min: min !== undefined ? axis.min + min : undefined,\n    max: max !== undefined ? axis.max + max - (axis.max - axis.min) : undefined\n  };\n}\n/**\n * Calculate constraints in terms of the viewport when\n * defined relatively to the measured bounding box.\n */\nfunction calcRelativeConstraints(layoutBox, _ref2) {\n  let {\n    top,\n    left,\n    bottom,\n    right\n  } = _ref2;\n  return {\n    x: calcRelativeAxisConstraints(layoutBox.x, left, right),\n    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)\n  };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative axis\n */\nfunction calcViewportAxisConstraints(layoutAxis, constraintsAxis) {\n  let min = constraintsAxis.min - layoutAxis.min;\n  let max = constraintsAxis.max - layoutAxis.max;\n  // If the constraints axis is actually smaller than the layout axis then we can\n  // flip the constraints\n  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {\n    [min, max] = [max, min];\n  }\n  return {\n    min,\n    max\n  };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative box\n */\nfunction calcViewportConstraints(layoutBox, constraintsBox) {\n  return {\n    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),\n    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)\n  };\n}\n/**\n * Calculate a transform origin relative to the source axis, between 0-1, that results\n * in an asthetically pleasing scale/transform needed to project from source to target.\n */\nfunction calcOrigin(source, target) {\n  let origin = 0.5;\n  const sourceLength = calcLength(source);\n  const targetLength = calcLength(target);\n  if (targetLength > sourceLength) {\n    origin = progress(target.min, target.max - sourceLength, source.min);\n  } else if (sourceLength > targetLength) {\n    origin = progress(source.min, source.max - targetLength, target.min);\n  }\n  return clamp(0, 1, origin);\n}\n/**\n * Rebase the calculated viewport constraints relative to the layout.min point.\n */\nfunction rebaseAxisConstraints(layout, constraints) {\n  const relativeConstraints = {};\n  if (constraints.min !== undefined) {\n    relativeConstraints.min = constraints.min - layout.min;\n  }\n  if (constraints.max !== undefined) {\n    relativeConstraints.max = constraints.max - layout.min;\n  }\n  return relativeConstraints;\n}\nconst defaultElastic = 0.35;\n/**\n * Accepts a dragElastic prop and returns resolved elastic values for each axis.\n */\nfunction resolveDragElastic() {\n  let dragElastic = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultElastic;\n  if (dragElastic === false) {\n    dragElastic = 0;\n  } else if (dragElastic === true) {\n    dragElastic = defaultElastic;\n  }\n  return {\n    x: resolveAxisElastic(dragElastic, \"left\", \"right\"),\n    y: resolveAxisElastic(dragElastic, \"top\", \"bottom\")\n  };\n}\nfunction resolveAxisElastic(dragElastic, minLabel, maxLabel) {\n  return {\n    min: resolvePointElastic(dragElastic, minLabel),\n    max: resolvePointElastic(dragElastic, maxLabel)\n  };\n}\nfunction resolvePointElastic(dragElastic, label) {\n  return typeof dragElastic === \"number\" ? dragElastic : dragElastic[label] || 0;\n}\nexport { applyConstraints, calcOrigin, calcRelativeAxisConstraints, calcRelativeConstraints, calcViewportAxisConstraints, calcViewportConstraints, defaultElastic, rebaseAxisConstraints, resolveAxisElastic, resolveDragElastic, resolvePointElastic };\n//# sourceMappingURL=constraints.mjs.map","import _objectSpread from \"/app/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { createBox, frame, eachAxis, measurePageBox, convertBoxToBoundingBox, convertBoundingBoxToBox, addValueToWillChange, animateMotionValue, mixNumber, isElementKeyboardAccessible, addDomEvent, setDragLock, percent, calcLength } from 'motion-dom';\nimport { invariant } from 'motion-utils';\nimport { addPointerEvent } from '../../events/add-pointer-event.mjs';\nimport { extractEventInfo } from '../../events/event-info.mjs';\nimport { getContextWindow } from '../../utils/get-context-window.mjs';\nimport { isRefObject } from '../../utils/is-ref-object.mjs';\nimport { PanSession } from '../pan/PanSession.mjs';\nimport { applyConstraints, calcRelativeConstraints, resolveDragElastic, rebaseAxisConstraints, calcViewportConstraints, calcOrigin, defaultElastic } from './utils/constraints.mjs';\nconst elementDragControls = new WeakMap();\nclass VisualElementDragControls {\n  constructor(visualElement) {\n    this.openDragLock = null;\n    this.isDragging = false;\n    this.currentDirection = null;\n    this.originPoint = {\n      x: 0,\n      y: 0\n    };\n    /**\n     * The permitted boundaries of travel, in pixels.\n     */\n    this.constraints = false;\n    this.hasMutatedConstraints = false;\n    /**\n     * The per-axis resolved elastic values.\n     */\n    this.elastic = createBox();\n    /**\n     * The latest pointer event. Used as fallback when the `cancel` and `stop` functions are called without arguments.\n     */\n    this.latestPointerEvent = null;\n    /**\n     * The latest pan info. Used as fallback when the `cancel` and `stop` functions are called without arguments.\n     */\n    this.latestPanInfo = null;\n    this.visualElement = visualElement;\n  }\n  start(originEvent) {\n    let {\n      snapToCursor = false,\n      distanceThreshold\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    /**\n     * Don't start dragging if this component is exiting\n     */\n    const {\n      presenceContext\n    } = this.visualElement;\n    if (presenceContext && presenceContext.isPresent === false) return;\n    const onSessionStart = event => {\n      // Stop or pause animations based on context:\n      // - snapToCursor: stop because we'll set new position values\n      // - otherwise: pause to allow resume if no drag starts (for constraint animations)\n      if (snapToCursor) {\n        this.stopAnimation();\n        this.snapToCursor(extractEventInfo(event).point);\n      } else {\n        this.pauseAnimation();\n      }\n    };\n    const onStart = (event, info) => {\n      // Stop any paused animation so motion values reflect true current position\n      // (pauseAnimation was called in onSessionStart to allow resume if no drag started)\n      this.stopAnimation();\n      // Attempt to grab the global drag gesture lock - maybe make this part of PanSession\n      const {\n        drag,\n        dragPropagation,\n        onDragStart\n      } = this.getProps();\n      if (drag && !dragPropagation) {\n        if (this.openDragLock) this.openDragLock();\n        this.openDragLock = setDragLock(drag);\n        // If we don 't have the lock, don't start dragging\n        if (!this.openDragLock) return;\n      }\n      this.latestPointerEvent = event;\n      this.latestPanInfo = info;\n      this.isDragging = true;\n      this.currentDirection = null;\n      this.resolveConstraints();\n      if (this.visualElement.projection) {\n        this.visualElement.projection.isAnimationBlocked = true;\n        this.visualElement.projection.target = undefined;\n      }\n      /**\n       * Record gesture origin and pointer offset\n       */\n      eachAxis(axis => {\n        let current = this.getAxisMotionValue(axis).get() || 0;\n        /**\n         * If the MotionValue is a percentage value convert to px\n         */\n        if (percent.test(current)) {\n          const {\n            projection\n          } = this.visualElement;\n          if (projection && projection.layout) {\n            const measuredAxis = projection.layout.layoutBox[axis];\n            if (measuredAxis) {\n              const length = calcLength(measuredAxis);\n              current = length * (parseFloat(current) / 100);\n            }\n          }\n        }\n        this.originPoint[axis] = current;\n      });\n      // Fire onDragStart event\n      if (onDragStart) {\n        frame.postRender(() => onDragStart(event, info));\n      }\n      addValueToWillChange(this.visualElement, \"transform\");\n      const {\n        animationState\n      } = this.visualElement;\n      animationState && animationState.setActive(\"whileDrag\", true);\n    };\n    const onMove = (event, info) => {\n      this.latestPointerEvent = event;\n      this.latestPanInfo = info;\n      const {\n        dragPropagation,\n        dragDirectionLock,\n        onDirectionLock,\n        onDrag\n      } = this.getProps();\n      // If we didn't successfully receive the gesture lock, early return.\n      if (!dragPropagation && !this.openDragLock) return;\n      const {\n        offset\n      } = info;\n      // Attempt to detect drag direction if directionLock is true\n      if (dragDirectionLock && this.currentDirection === null) {\n        this.currentDirection = getCurrentDirection(offset);\n        // If we've successfully set a direction, notify listener\n        if (this.currentDirection !== null) {\n          onDirectionLock && onDirectionLock(this.currentDirection);\n        }\n        return;\n      }\n      // Update each point with the latest position\n      this.updateAxis(\"x\", info.point, offset);\n      this.updateAxis(\"y\", info.point, offset);\n      /**\n       * Ideally we would leave the renderer to fire naturally at the end of\n       * this frame but if the element is about to change layout as the result\n       * of a re-render we want to ensure the browser can read the latest\n       * bounding box to ensure the pointer and element don't fall out of sync.\n       */\n      this.visualElement.render();\n      /**\n       * This must fire after the render call as it might trigger a state\n       * change which itself might trigger a layout update.\n       */\n      onDrag && onDrag(event, info);\n    };\n    const onSessionEnd = (event, info) => {\n      this.latestPointerEvent = event;\n      this.latestPanInfo = info;\n      this.stop(event, info);\n      this.latestPointerEvent = null;\n      this.latestPanInfo = null;\n    };\n    const resumeAnimation = () => eachAxis(axis => {\n      var _this$getAxisMotionVa;\n      return this.getAnimationState(axis) === \"paused\" && ((_this$getAxisMotionVa = this.getAxisMotionValue(axis).animation) === null || _this$getAxisMotionVa === void 0 ? void 0 : _this$getAxisMotionVa.play());\n    });\n    const {\n      dragSnapToOrigin\n    } = this.getProps();\n    this.panSession = new PanSession(originEvent, {\n      onSessionStart,\n      onStart,\n      onMove,\n      onSessionEnd,\n      resumeAnimation\n    }, {\n      transformPagePoint: this.visualElement.getTransformPagePoint(),\n      dragSnapToOrigin,\n      distanceThreshold,\n      contextWindow: getContextWindow(this.visualElement),\n      element: this.visualElement.current\n    });\n  }\n  /**\n   * @internal\n   */\n  stop(event, panInfo) {\n    const finalEvent = event || this.latestPointerEvent;\n    const finalPanInfo = panInfo || this.latestPanInfo;\n    const isDragging = this.isDragging;\n    this.cancel();\n    if (!isDragging || !finalPanInfo || !finalEvent) return;\n    const {\n      velocity\n    } = finalPanInfo;\n    this.startAnimation(velocity);\n    const {\n      onDragEnd\n    } = this.getProps();\n    if (onDragEnd) {\n      frame.postRender(() => onDragEnd(finalEvent, finalPanInfo));\n    }\n  }\n  /**\n   * @internal\n   */\n  cancel() {\n    this.isDragging = false;\n    const {\n      projection,\n      animationState\n    } = this.visualElement;\n    if (projection) {\n      projection.isAnimationBlocked = false;\n    }\n    this.panSession && this.panSession.end();\n    this.panSession = undefined;\n    const {\n      dragPropagation\n    } = this.getProps();\n    if (!dragPropagation && this.openDragLock) {\n      this.openDragLock();\n      this.openDragLock = null;\n    }\n    animationState && animationState.setActive(\"whileDrag\", false);\n  }\n  updateAxis(axis, _point, offset) {\n    const {\n      drag\n    } = this.getProps();\n    // If we're not dragging this axis, do an early return.\n    if (!offset || !shouldDrag(axis, drag, this.currentDirection)) return;\n    const axisValue = this.getAxisMotionValue(axis);\n    let next = this.originPoint[axis] + offset[axis];\n    // Apply constraints\n    if (this.constraints && this.constraints[axis]) {\n      next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);\n    }\n    axisValue.set(next);\n  }\n  resolveConstraints() {\n    var _this$visualElement$p;\n    const {\n      dragConstraints,\n      dragElastic\n    } = this.getProps();\n    const layout = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(false) : (_this$visualElement$p = this.visualElement.projection) === null || _this$visualElement$p === void 0 ? void 0 : _this$visualElement$p.layout;\n    const prevConstraints = this.constraints;\n    if (dragConstraints && isRefObject(dragConstraints)) {\n      if (!this.constraints) {\n        this.constraints = this.resolveRefConstraints();\n      }\n    } else {\n      if (dragConstraints && layout) {\n        this.constraints = calcRelativeConstraints(layout.layoutBox, dragConstraints);\n      } else {\n        this.constraints = false;\n      }\n    }\n    this.elastic = resolveDragElastic(dragElastic);\n    /**\n     * If we're outputting to external MotionValues, we want to rebase the measured constraints\n     * from viewport-relative to component-relative.\n     */\n    if (prevConstraints !== this.constraints && layout && this.constraints && !this.hasMutatedConstraints) {\n      eachAxis(axis => {\n        if (this.constraints !== false && this.getAxisMotionValue(axis)) {\n          this.constraints[axis] = rebaseAxisConstraints(layout.layoutBox[axis], this.constraints[axis]);\n        }\n      });\n    }\n  }\n  resolveRefConstraints() {\n    const {\n      dragConstraints: constraints,\n      onMeasureDragConstraints\n    } = this.getProps();\n    if (!constraints || !isRefObject(constraints)) return false;\n    const constraintsElement = constraints.current;\n    invariant(constraintsElement !== null, \"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.\", \"drag-constraints-ref\");\n    const {\n      projection\n    } = this.visualElement;\n    // TODO\n    if (!projection || !projection.layout) return false;\n    const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());\n    let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);\n    /**\n     * If there's an onMeasureDragConstraints listener we call it and\n     * if different constraints are returned, set constraints to that\n     */\n    if (onMeasureDragConstraints) {\n      const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));\n      this.hasMutatedConstraints = !!userConstraints;\n      if (userConstraints) {\n        measuredConstraints = convertBoundingBoxToBox(userConstraints);\n      }\n    }\n    return measuredConstraints;\n  }\n  startAnimation(velocity) {\n    const {\n      drag,\n      dragMomentum,\n      dragElastic,\n      dragTransition,\n      dragSnapToOrigin,\n      onDragTransitionEnd\n    } = this.getProps();\n    const constraints = this.constraints || {};\n    const momentumAnimations = eachAxis(axis => {\n      if (!shouldDrag(axis, drag, this.currentDirection)) {\n        return;\n      }\n      let transition = constraints && constraints[axis] || {};\n      if (dragSnapToOrigin) transition = {\n        min: 0,\n        max: 0\n      };\n      /**\n       * Overdamp the boundary spring if `dragElastic` is disabled. There's still a frame\n       * of spring animations so we should look into adding a disable spring option to `inertia`.\n       * We could do something here where we affect the `bounceStiffness` and `bounceDamping`\n       * using the value of `dragElastic`.\n       */\n      const bounceStiffness = dragElastic ? 200 : 1000000;\n      const bounceDamping = dragElastic ? 40 : 10000000;\n      const inertia = _objectSpread(_objectSpread({\n        type: \"inertia\",\n        velocity: dragMomentum ? velocity[axis] : 0,\n        bounceStiffness,\n        bounceDamping,\n        timeConstant: 750,\n        restDelta: 1,\n        restSpeed: 10\n      }, dragTransition), transition);\n      // If we're not animating on an externally-provided `MotionValue` we can use the\n      // component's animation controls which will handle interactions with whileHover (etc),\n      // otherwise we just have to animate the `MotionValue` itself.\n      return this.startAxisValueAnimation(axis, inertia);\n    });\n    // Run all animations and then resolve the new drag constraints.\n    return Promise.all(momentumAnimations).then(onDragTransitionEnd);\n  }\n  startAxisValueAnimation(axis, transition) {\n    const axisValue = this.getAxisMotionValue(axis);\n    addValueToWillChange(this.visualElement, axis);\n    return axisValue.start(animateMotionValue(axis, axisValue, 0, transition, this.visualElement, false));\n  }\n  stopAnimation() {\n    eachAxis(axis => this.getAxisMotionValue(axis).stop());\n  }\n  pauseAnimation() {\n    eachAxis(axis => {\n      var _this$getAxisMotionVa2;\n      return (_this$getAxisMotionVa2 = this.getAxisMotionValue(axis).animation) === null || _this$getAxisMotionVa2 === void 0 ? void 0 : _this$getAxisMotionVa2.pause();\n    });\n  }\n  getAnimationState(axis) {\n    var _this$getAxisMotionVa3;\n    return (_this$getAxisMotionVa3 = this.getAxisMotionValue(axis).animation) === null || _this$getAxisMotionVa3 === void 0 ? void 0 : _this$getAxisMotionVa3.state;\n  }\n  /**\n   * Drag works differently depending on which props are provided.\n   *\n   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.\n   * - Otherwise, we apply the delta to the x/y motion values.\n   */\n  getAxisMotionValue(axis) {\n    const dragKey = \"_drag\".concat(axis.toUpperCase());\n    const props = this.visualElement.getProps();\n    const externalMotionValue = props[dragKey];\n    return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, (props.initial ? props.initial[axis] : undefined) || 0);\n  }\n  snapToCursor(point) {\n    eachAxis(axis => {\n      const {\n        drag\n      } = this.getProps();\n      // If we're not dragging this axis, do an early return.\n      if (!shouldDrag(axis, drag, this.currentDirection)) return;\n      const {\n        projection\n      } = this.visualElement;\n      const axisValue = this.getAxisMotionValue(axis);\n      if (projection && projection.layout) {\n        const {\n          min,\n          max\n        } = projection.layout.layoutBox[axis];\n        /**\n         * The layout measurement includes the current transform value,\n         * so we need to add it back to get the correct snap position.\n         * This fixes an issue where elements with initial coordinates\n         * would snap to the wrong position on the first drag.\n         */\n        const current = axisValue.get() || 0;\n        axisValue.set(point[axis] - mixNumber(min, max, 0.5) + current);\n      }\n    });\n  }\n  /**\n   * When the viewport resizes we want to check if the measured constraints\n   * have changed and, if so, reposition the element within those new constraints\n   * relative to where it was before the resize.\n   */\n  scalePositionWithinConstraints() {\n    if (!this.visualElement.current) return;\n    const {\n      drag,\n      dragConstraints\n    } = this.getProps();\n    const {\n      projection\n    } = this.visualElement;\n    if (!isRefObject(dragConstraints) || !projection || !this.constraints) return;\n    /**\n     * Stop current animations as there can be visual glitching if we try to do\n     * this mid-animation\n     */\n    this.stopAnimation();\n    /**\n     * Record the relative position of the dragged element relative to the\n     * constraints box and save as a progress value.\n     */\n    const boxProgress = {\n      x: 0,\n      y: 0\n    };\n    eachAxis(axis => {\n      const axisValue = this.getAxisMotionValue(axis);\n      if (axisValue && this.constraints !== false) {\n        const latest = axisValue.get();\n        boxProgress[axis] = calcOrigin({\n          min: latest,\n          max: latest\n        }, this.constraints[axis]);\n      }\n    });\n    /**\n     * Update the layout of this element and resolve the latest drag constraints\n     */\n    const {\n      transformTemplate\n    } = this.visualElement.getProps();\n    this.visualElement.current.style.transform = transformTemplate ? transformTemplate({}, \"\") : \"none\";\n    projection.root && projection.root.updateScroll();\n    projection.updateLayout();\n    this.resolveConstraints();\n    /**\n     * For each axis, calculate the current progress of the layout axis\n     * within the new constraints.\n     */\n    eachAxis(axis => {\n      if (!shouldDrag(axis, drag, null)) return;\n      /**\n       * Calculate a new transform based on the previous box progress\n       */\n      const axisValue = this.getAxisMotionValue(axis);\n      const {\n        min,\n        max\n      } = this.constraints[axis];\n      axisValue.set(mixNumber(min, max, boxProgress[axis]));\n    });\n  }\n  addListeners() {\n    if (!this.visualElement.current) return;\n    elementDragControls.set(this.visualElement, this);\n    const element = this.visualElement.current;\n    /**\n     * Attach a pointerdown event listener on this DOM element to initiate drag tracking.\n     */\n    const stopPointerListener = addPointerEvent(element, \"pointerdown\", event => {\n      const {\n        drag,\n        dragListener = true\n      } = this.getProps();\n      if (drag && dragListener && !isElementKeyboardAccessible(event.target)) {\n        this.start(event);\n      }\n    });\n    const measureDragConstraints = () => {\n      const {\n        dragConstraints\n      } = this.getProps();\n      if (isRefObject(dragConstraints) && dragConstraints.current) {\n        this.constraints = this.resolveRefConstraints();\n      }\n    };\n    const {\n      projection\n    } = this.visualElement;\n    const stopMeasureLayoutListener = projection.addEventListener(\"measure\", measureDragConstraints);\n    if (projection && !projection.layout) {\n      projection.root && projection.root.updateScroll();\n      projection.updateLayout();\n    }\n    frame.read(measureDragConstraints);\n    /**\n     * Attach a window resize listener to scale the draggable target within its defined\n     * constraints as the window resizes.\n     */\n    const stopResizeListener = addDomEvent(window, \"resize\", () => this.scalePositionWithinConstraints());\n    /**\n     * If the element's layout changes, calculate the delta and apply that to\n     * the drag gesture's origin point.\n     */\n    const stopLayoutUpdateListener = projection.addEventListener(\"didUpdate\", _ref => {\n      let {\n        delta,\n        hasLayoutChanged\n      } = _ref;\n      if (this.isDragging && hasLayoutChanged) {\n        eachAxis(axis => {\n          const motionValue = this.getAxisMotionValue(axis);\n          if (!motionValue) return;\n          this.originPoint[axis] += delta[axis].translate;\n          motionValue.set(motionValue.get() + delta[axis].translate);\n        });\n        this.visualElement.render();\n      }\n    });\n    return () => {\n      stopResizeListener();\n      stopPointerListener();\n      stopMeasureLayoutListener();\n      stopLayoutUpdateListener && stopLayoutUpdateListener();\n    };\n  }\n  getProps() {\n    const props = this.visualElement.getProps();\n    const {\n      drag = false,\n      dragDirectionLock = false,\n      dragPropagation = false,\n      dragConstraints = false,\n      dragElastic = defaultElastic,\n      dragMomentum = true\n    } = props;\n    return _objectSpread(_objectSpread({}, props), {}, {\n      drag,\n      dragDirectionLock,\n      dragPropagation,\n      dragConstraints,\n      dragElastic,\n      dragMomentum\n    });\n  }\n}\nfunction shouldDrag(direction, drag, currentDirection) {\n  return (drag === true || drag === direction) && (currentDirection === null || currentDirection === direction);\n}\n/**\n * Based on an x/y offset determine the current drag direction. If both axis' offsets are lower\n * than the provided threshold, return `null`.\n *\n * @param offset - The x/y offset from origin.\n * @param lockThreshold - (Optional) - the minimum absolute offset before we can determine a drag direction.\n */\nfunction getCurrentDirection(offset) {\n  let lockThreshold = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n  let direction = null;\n  if (Math.abs(offset.y) > lockThreshold) {\n    direction = \"y\";\n  } else if (Math.abs(offset.x) > lockThreshold) {\n    direction = \"x\";\n  }\n  return direction;\n}\nexport { VisualElementDragControls, elementDragControls };\n//# sourceMappingURL=VisualElementDragControls.mjs.map","import { Feature } from 'motion-dom';\nimport { noop } from 'motion-utils';\nimport { VisualElementDragControls } from './VisualElementDragControls.mjs';\nclass DragGesture extends Feature {\n  constructor(node) {\n    super(node);\n    this.removeGroupControls = noop;\n    this.removeListeners = noop;\n    this.controls = new VisualElementDragControls(node);\n  }\n  mount() {\n    // If we've been provided a DragControls for manual control over the drag gesture,\n    // subscribe this component to it on mount.\n    const {\n      dragControls\n    } = this.node.getProps();\n    if (dragControls) {\n      this.removeGroupControls = dragControls.subscribe(this.controls);\n    }\n    this.removeListeners = this.controls.addListeners() || noop;\n  }\n  update() {\n    const {\n      dragControls\n    } = this.node.getProps();\n    const {\n      dragControls: prevDragControls\n    } = this.node.prevProps || {};\n    if (dragControls !== prevDragControls) {\n      this.removeGroupControls();\n      if (dragControls) {\n        this.removeGroupControls = dragControls.subscribe(this.controls);\n      }\n    }\n  }\n  unmount() {\n    this.removeGroupControls();\n    this.removeListeners();\n  }\n}\nexport { DragGesture };\n//# sourceMappingURL=index.mjs.map","import { Feature, frame } from 'motion-dom';\nimport { noop } from 'motion-utils';\nimport { addPointerEvent } from '../../events/add-pointer-event.mjs';\nimport { getContextWindow } from '../../utils/get-context-window.mjs';\nimport { PanSession } from './PanSession.mjs';\nconst asyncHandler = handler => (event, info) => {\n  if (handler) {\n    frame.postRender(() => handler(event, info));\n  }\n};\nclass PanGesture extends Feature {\n  constructor() {\n    super(...arguments);\n    this.removePointerDownListener = noop;\n  }\n  onPointerDown(pointerDownEvent) {\n    this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {\n      transformPagePoint: this.node.getTransformPagePoint(),\n      contextWindow: getContextWindow(this.node)\n    });\n  }\n  createPanHandlers() {\n    const {\n      onPanSessionStart,\n      onPanStart,\n      onPan,\n      onPanEnd\n    } = this.node.getProps();\n    return {\n      onSessionStart: asyncHandler(onPanSessionStart),\n      onStart: asyncHandler(onPanStart),\n      onMove: onPan,\n      onEnd: (event, info) => {\n        delete this.session;\n        if (onPanEnd) {\n          frame.postRender(() => onPanEnd(event, info));\n        }\n      }\n    };\n  }\n  mount() {\n    this.removePointerDownListener = addPointerEvent(this.node.current, \"pointerdown\", event => this.onPointerDown(event));\n  }\n  update() {\n    this.session && this.session.updateHandlers(this.createPanHandlers());\n  }\n  unmount() {\n    this.removePointerDownListener();\n    this.session && this.session.end();\n  }\n}\nexport { PanGesture };\n//# sourceMappingURL=index.mjs.map","\"use client\";\n\nimport _objectSpread from \"/app/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { jsx } from 'react/jsx-runtime';\nimport { globalProjectionState, frame, microtask } from 'motion-dom';\nimport { useContext, Component } from 'react';\nimport { usePresence } from '../../../components/AnimatePresence/use-presence.mjs';\nimport { LayoutGroupContext } from '../../../context/LayoutGroupContext.mjs';\nimport { SwitchLayoutGroupContext } from '../../../context/SwitchLayoutGroupContext.mjs';\n\n/**\n * Track whether we've taken any snapshots yet. If not,\n * we can safely skip notification of didUpdate.\n *\n * Difficult to capture in a test but to prevent flickering\n * we must set this to true either on update or unmount.\n * Running `next-env/layout-id` in Safari will show this behaviour if broken.\n */\nlet hasTakenAnySnapshot = false;\nclass MeasureLayoutWithContext extends Component {\n  /**\n   * This only mounts projection nodes for components that\n   * need measuring, we might want to do it for all components\n   * in order to incorporate transforms\n   */\n  componentDidMount() {\n    const {\n      visualElement,\n      layoutGroup,\n      switchLayoutGroup,\n      layoutId\n    } = this.props;\n    const {\n      projection\n    } = visualElement;\n    if (projection) {\n      if (layoutGroup.group) layoutGroup.group.add(projection);\n      if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {\n        switchLayoutGroup.register(projection);\n      }\n      if (hasTakenAnySnapshot) {\n        projection.root.didUpdate();\n      }\n      projection.addEventListener(\"animationComplete\", () => {\n        this.safeToRemove();\n      });\n      projection.setOptions(_objectSpread(_objectSpread({}, projection.options), {}, {\n        onExitComplete: () => this.safeToRemove()\n      }));\n    }\n    globalProjectionState.hasEverUpdated = true;\n  }\n  getSnapshotBeforeUpdate(prevProps) {\n    const {\n      layoutDependency,\n      visualElement,\n      drag,\n      isPresent\n    } = this.props;\n    const {\n      projection\n    } = visualElement;\n    if (!projection) return null;\n    /**\n     * TODO: We use this data in relegate to determine whether to\n     * promote a previous element. There's no guarantee its presence data\n     * will have updated by this point - if a bug like this arises it will\n     * have to be that we markForRelegation and then find a new lead some other way,\n     * perhaps in didUpdate\n     */\n    projection.isPresent = isPresent;\n    hasTakenAnySnapshot = true;\n    if (drag || prevProps.layoutDependency !== layoutDependency || layoutDependency === undefined || prevProps.isPresent !== isPresent) {\n      projection.willUpdate();\n    } else {\n      this.safeToRemove();\n    }\n    if (prevProps.isPresent !== isPresent) {\n      if (isPresent) {\n        projection.promote();\n      } else if (!projection.relegate()) {\n        /**\n         * If there's another stack member taking over from this one,\n         * it's in charge of the exit animation and therefore should\n         * be in charge of the safe to remove. Otherwise we call it here.\n         */\n        frame.postRender(() => {\n          const stack = projection.getStack();\n          if (!stack || !stack.members.length) {\n            this.safeToRemove();\n          }\n        });\n      }\n    }\n    return null;\n  }\n  componentDidUpdate() {\n    const {\n      projection\n    } = this.props.visualElement;\n    if (projection) {\n      projection.root.didUpdate();\n      microtask.postRender(() => {\n        if (!projection.currentAnimation && projection.isLead()) {\n          this.safeToRemove();\n        }\n      });\n    }\n  }\n  componentWillUnmount() {\n    const {\n      visualElement,\n      layoutGroup,\n      switchLayoutGroup: promoteContext\n    } = this.props;\n    const {\n      projection\n    } = visualElement;\n    hasTakenAnySnapshot = true;\n    if (projection) {\n      projection.scheduleCheckAfterUnmount();\n      if (layoutGroup && layoutGroup.group) layoutGroup.group.remove(projection);\n      if (promoteContext && promoteContext.deregister) promoteContext.deregister(projection);\n    }\n  }\n  safeToRemove() {\n    const {\n      safeToRemove\n    } = this.props;\n    safeToRemove && safeToRemove();\n  }\n  render() {\n    return null;\n  }\n}\nfunction MeasureLayout(props) {\n  const [isPresent, safeToRemove] = usePresence();\n  const layoutGroup = useContext(LayoutGroupContext);\n  return jsx(MeasureLayoutWithContext, _objectSpread(_objectSpread({}, props), {}, {\n    layoutGroup: layoutGroup,\n    switchLayoutGroup: useContext(SwitchLayoutGroupContext),\n    isPresent: isPresent,\n    safeToRemove: safeToRemove\n  }));\n}\nexport { MeasureLayout };\n//# sourceMappingURL=MeasureLayout.mjs.map","\"use client\";\n\nimport { useContext, useId, useEffect, useCallback } from 'react';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\n\n/**\n * When a component is the child of `AnimatePresence`, it can use `usePresence`\n * to access information about whether it's still present in the React tree.\n *\n * ```jsx\n * import { usePresence } from \"framer-motion\"\n *\n * export const Component = () => {\n *   const [isPresent, safeToRemove] = usePresence()\n *\n *   useEffect(() => {\n *     !isPresent && setTimeout(safeToRemove, 1000)\n *   }, [isPresent])\n *\n *   return <div />\n * }\n * ```\n *\n * If `isPresent` is `false`, it means that a component has been removed the tree, but\n * `AnimatePresence` won't really remove it until `safeToRemove` has been called.\n *\n * @public\n */\nfunction usePresence() {\n  let subscribe = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n  const context = useContext(PresenceContext);\n  if (context === null) return [true, null];\n  const {\n    isPresent,\n    onExitComplete,\n    register\n  } = context;\n  // It's safe to call the following hooks conditionally (after an early return) because the context will always\n  // either be null or non-null for the lifespan of the component.\n  const id = useId();\n  useEffect(() => {\n    if (subscribe) {\n      return register(id);\n    }\n  }, [subscribe]);\n  const safeToRemove = useCallback(() => subscribe && onExitComplete && onExitComplete(id), [id, onExitComplete, subscribe]);\n  return !isPresent && onExitComplete ? [false, safeToRemove] : [true];\n}\n/**\n * Similar to `usePresence`, except `useIsPresent` simply returns whether or not the component is present.\n * There is no `safeToRemove` function.\n *\n * ```jsx\n * import { useIsPresent } from \"framer-motion\"\n *\n * export const Component = () => {\n *   const isPresent = useIsPresent()\n *\n *   useEffect(() => {\n *     !isPresent && console.log(\"I've been removed!\")\n *   }, [isPresent])\n *\n *   return <div />\n * }\n * ```\n *\n * @public\n */\nfunction useIsPresent() {\n  return isPresent(useContext(PresenceContext));\n}\nfunction isPresent(context) {\n  return context === null ? true : context.isPresent;\n}\nexport { isPresent, useIsPresent, usePresence };\n//# sourceMappingURL=use-presence.mjs.map","import { DragGesture } from '../../gestures/drag/index.mjs';\nimport { PanGesture } from '../../gestures/pan/index.mjs';\nimport { MeasureLayout } from './layout/MeasureLayout.mjs';\nimport { HTMLProjectionNode } from 'motion-dom';\nconst drag = {\n  pan: {\n    Feature: PanGesture\n  },\n  drag: {\n    Feature: DragGesture,\n    ProjectionNode: HTMLProjectionNode,\n    MeasureLayout\n  }\n};\nexport { drag };\n//# sourceMappingURL=drag.mjs.map","import { Feature, hover, frame } from 'motion-dom';\nimport { extractEventInfo } from '../events/event-info.mjs';\nfunction handleHoverEvent(node, event, lifecycle) {\n  const {\n    props\n  } = node;\n  if (node.animationState && props.whileHover) {\n    node.animationState.setActive(\"whileHover\", lifecycle === \"Start\");\n  }\n  const eventName = \"onHover\" + lifecycle;\n  const callback = props[eventName];\n  if (callback) {\n    frame.postRender(() => callback(event, extractEventInfo(event)));\n  }\n}\nclass HoverGesture extends Feature {\n  mount() {\n    const {\n      current\n    } = this.node;\n    if (!current) return;\n    this.unmount = hover(current, (_element, startEvent) => {\n      handleHoverEvent(this.node, startEvent, \"Start\");\n      return endEvent => handleHoverEvent(this.node, endEvent, \"End\");\n    });\n  }\n  unmount() {}\n}\nexport { HoverGesture };\n//# sourceMappingURL=hover.mjs.map","import { Feature, addDomEvent } from 'motion-dom';\nimport { pipe } from 'motion-utils';\nclass FocusGesture extends Feature {\n  constructor() {\n    super(...arguments);\n    this.isActive = false;\n  }\n  onFocus() {\n    let isFocusVisible = false;\n    /**\n     * If this element doesn't match focus-visible then don't\n     * apply whileHover. But, if matches throws that focus-visible\n     * is not a valid selector then in that browser outline styles will be applied\n     * to the element by default and we want to match that behaviour with whileFocus.\n     */\n    try {\n      isFocusVisible = this.node.current.matches(\":focus-visible\");\n    } catch (e) {\n      isFocusVisible = true;\n    }\n    if (!isFocusVisible || !this.node.animationState) return;\n    this.node.animationState.setActive(\"whileFocus\", true);\n    this.isActive = true;\n  }\n  onBlur() {\n    if (!this.isActive || !this.node.animationState) return;\n    this.node.animationState.setActive(\"whileFocus\", false);\n    this.isActive = false;\n  }\n  mount() {\n    this.unmount = pipe(addDomEvent(this.node.current, \"focus\", () => this.onFocus()), addDomEvent(this.node.current, \"blur\", () => this.onBlur()));\n  }\n  unmount() {}\n}\nexport { FocusGesture };\n//# sourceMappingURL=focus.mjs.map","import { Feature, press, frame } from 'motion-dom';\nimport { extractEventInfo } from '../events/event-info.mjs';\nfunction handlePressEvent(node, event, lifecycle) {\n  const {\n    props\n  } = node;\n  if (node.current instanceof HTMLButtonElement && node.current.disabled) {\n    return;\n  }\n  if (node.animationState && props.whileTap) {\n    node.animationState.setActive(\"whileTap\", lifecycle === \"Start\");\n  }\n  const eventName = \"onTap\" + (lifecycle === \"End\" ? \"\" : lifecycle);\n  const callback = props[eventName];\n  if (callback) {\n    frame.postRender(() => callback(event, extractEventInfo(event)));\n  }\n}\nclass PressGesture extends Feature {\n  mount() {\n    const {\n      current\n    } = this.node;\n    if (!current) return;\n    this.unmount = press(current, (_element, startEvent) => {\n      handlePressEvent(this.node, startEvent, \"Start\");\n      return (endEvent, _ref) => {\n        let {\n          success\n        } = _ref;\n        return handlePressEvent(this.node, endEvent, success ? \"End\" : \"Cancel\");\n      };\n    }, {\n      useGlobalTarget: this.node.props.globalTapTarget\n    });\n  }\n  unmount() {}\n}\nexport { PressGesture };\n//# sourceMappingURL=press.mjs.map","import _objectSpread from \"/app/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/app/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"root\"];\n/**\n * Map an IntersectionHandler callback to an element. We only ever make one handler for one\n * element, so even though these handlers might all be triggered by different\n * observers, we can keep them in the same map.\n */\nconst observerCallbacks = new WeakMap();\n/**\n * Multiple observers can be created for multiple element/document roots. Each with\n * different settings. So here we store dictionaries of observers to each root,\n * using serialised settings (threshold/margin) as lookup keys.\n */\nconst observers = new WeakMap();\nconst fireObserverCallback = entry => {\n  const callback = observerCallbacks.get(entry.target);\n  callback && callback(entry);\n};\nconst fireAllObserverCallbacks = entries => {\n  entries.forEach(fireObserverCallback);\n};\nfunction initIntersectionObserver(_ref) {\n  let {\n      root\n    } = _ref,\n    options = _objectWithoutProperties(_ref, _excluded);\n  const lookupRoot = root || document;\n  /**\n   * If we don't have an observer lookup map for this root, create one.\n   */\n  if (!observers.has(lookupRoot)) {\n    observers.set(lookupRoot, {});\n  }\n  const rootObservers = observers.get(lookupRoot);\n  const key = JSON.stringify(options);\n  /**\n   * If we don't have an observer for this combination of root and settings,\n   * create one.\n   */\n  if (!rootObservers[key]) {\n    rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, _objectSpread({\n      root\n    }, options));\n  }\n  return rootObservers[key];\n}\nfunction observeIntersection(element, options, callback) {\n  const rootInteresectionObserver = initIntersectionObserver(options);\n  observerCallbacks.set(element, callback);\n  rootInteresectionObserver.observe(element);\n  return () => {\n    observerCallbacks.delete(element);\n    rootInteresectionObserver.unobserve(element);\n  };\n}\nexport { observeIntersection };\n//# sourceMappingURL=observers.mjs.map","import { Feature } from 'motion-dom';\nimport { observeIntersection } from './observers.mjs';\nconst thresholdNames = {\n  some: 0,\n  all: 1\n};\nclass InViewFeature extends Feature {\n  constructor() {\n    super(...arguments);\n    this.hasEnteredView = false;\n    this.isInView = false;\n  }\n  startObserver() {\n    this.unmount();\n    const {\n      viewport = {}\n    } = this.node.getProps();\n    const {\n      root,\n      margin: rootMargin,\n      amount = \"some\",\n      once\n    } = viewport;\n    const options = {\n      root: root ? root.current : undefined,\n      rootMargin,\n      threshold: typeof amount === \"number\" ? amount : thresholdNames[amount]\n    };\n    const onIntersectionUpdate = entry => {\n      const {\n        isIntersecting\n      } = entry;\n      /**\n       * If there's been no change in the viewport state, early return.\n       */\n      if (this.isInView === isIntersecting) return;\n      this.isInView = isIntersecting;\n      /**\n       * Handle hasEnteredView. If this is only meant to run once, and\n       * element isn't visible, early return. Otherwise set hasEnteredView to true.\n       */\n      if (once && !isIntersecting && this.hasEnteredView) {\n        return;\n      } else if (isIntersecting) {\n        this.hasEnteredView = true;\n      }\n      if (this.node.animationState) {\n        this.node.animationState.setActive(\"whileInView\", isIntersecting);\n      }\n      /**\n       * Use the latest committed props rather than the ones in scope\n       * when this observer is created\n       */\n      const {\n        onViewportEnter,\n        onViewportLeave\n      } = this.node.getProps();\n      const callback = isIntersecting ? onViewportEnter : onViewportLeave;\n      callback && callback(entry);\n    };\n    return observeIntersection(this.node.current, options, onIntersectionUpdate);\n  }\n  mount() {\n    this.startObserver();\n  }\n  update() {\n    if (typeof IntersectionObserver === \"undefined\") return;\n    const {\n      props,\n      prevProps\n    } = this.node;\n    const hasOptionsChanged = [\"amount\", \"margin\", \"root\"].some(hasViewportOptionChanged(props, prevProps));\n    if (hasOptionsChanged) {\n      this.startObserver();\n    }\n  }\n  unmount() {}\n}\nfunction hasViewportOptionChanged(_ref) {\n  let {\n    viewport = {}\n  } = _ref;\n  let {\n    viewport: prevViewport = {}\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return name => viewport[name] !== prevViewport[name];\n}\nexport { InViewFeature };\n//# sourceMappingURL=index.mjs.map","import { HoverGesture } from '../../gestures/hover.mjs';\nimport { FocusGesture } from '../../gestures/focus.mjs';\nimport { PressGesture } from '../../gestures/press.mjs';\nimport { InViewFeature } from './viewport/index.mjs';\nconst gestureAnimations = {\n  inView: {\n    Feature: InViewFeature\n  },\n  tap: {\n    Feature: PressGesture\n  },\n  focus: {\n    Feature: FocusGesture\n  },\n  hover: {\n    Feature: HoverGesture\n  }\n};\nexport { gestureAnimations };\n//# sourceMappingURL=gestures.mjs.map","import { HTMLProjectionNode } from 'motion-dom';\nimport { MeasureLayout } from './layout/MeasureLayout.mjs';\nconst layout = {\n  layout: {\n    ProjectionNode: HTMLProjectionNode,\n    MeasureLayout\n  }\n};\nexport { layout };\n//# sourceMappingURL=layout.mjs.map","import { createDomVisualElement } from '../../dom/create-visual-element.mjs';\nimport { createMotionProxy } from '../create-proxy.mjs';\nimport { featureBundle } from './feature-bundle.mjs';\nconst motion = /*@__PURE__*/createMotionProxy(featureBundle, createDomVisualElement);\nexport { motion };\n//# sourceMappingURL=proxy.mjs.map","import _objectSpread from \"/app/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { animations } from '../../../motion/features/animations.mjs';\nimport { drag } from '../../../motion/features/drag.mjs';\nimport { gestureAnimations } from '../../../motion/features/gestures.mjs';\nimport { layout } from '../../../motion/features/layout.mjs';\nconst featureBundle = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, animations), gestureAnimations), drag), layout);\nexport { featureBundle };\n//# sourceMappingURL=feature-bundle.mjs.map"],"names":["lowercaseSVGElements","isSVGComponent","Component","includes","indexOf","test","createDomVisualElement","options","_options$isSVG","isSVG","SVGVisualElement","HTMLVisualElement","allowProjection","Fragment","LayoutGroupContext","createContext","LazyContext","strict","MotionConfigContext","transformPagePoint","p","isStatic","reducedMotion","MotionContext","useCreateMotionContext","props","initial","animate","context","undefined","inherit","getCurrentTreeVariants","useContext","useMemo","variantLabelsAsDependency","prop","Array","isArray","join","createHtmlRenderState","style","transform","transformOrigin","vars","copyRawValuesOnly","target","source","key","useStyle","visualState","Object","assign","_ref","transformTemplate","state","useInitialMotionValues","useHTMLProps","htmlProps","drag","dragListener","draggable","userSelect","WebkitUserSelect","WebkitTouchCallout","touchAction","concat","tabIndex","onTap","onTapStart","whileTap","createSvgRenderState","attrs","useSVGProps","_isStatic","visualProps","rawStyles","validMotionProps","Set","isValidMotionProp","startsWith","has","shouldForward","isValidProp","require","default","_unused","useRender","ref","latestValues","forwardMotionProps","arguments","length","filteredProps","isDom","values","filterProps","elementProps","children","renderedChildren","get","createElement","_excluded","makeLatestValues","presenceContext","scrapeMotionValues","motionValues","isControllingVariants$1","isVariantNode$1","isInitialAnimationBlocked","variantToSet","list","i","resolved","transitionEnd","transition","valueTarget","makeUseVisualState","config","make","scrapeMotionValuesFromProps","createRenderState","renderState","makeState","init","useRef","current","useConstant","useHTMLVisualState","useSVGVisualState","isBrowser","window","featureProps","animation","exit","focus","hover","tap","pan","inView","layout","isInitialized","getInitializedFeatureDefinitions","initialFeatureDefinitions","isEnabled","some","name","initFeatureDefinitions","motionComponentSymbol","Symbol","for","useMotionRef","visualElement","externalRef","externalRefContainer","useInsertionEffect","refCleanup","useCallback","instance","_visualState$onMount","onMount","call","mount","unmount","cleanup","SwitchLayoutGroupContext","isRefObject","prototype","hasOwnProperty","useIsomorphicLayoutEffect","useLayoutEffect","useEffect","useVisualElement","createVisualElement","ProjectionNodeConstructor","_window$MotionHandoff","_window","_window$MotionHasOpti","_window2","parent","lazyContext","reducedMotionConfig","visualElementRef","renderer","blockInitialAnimation","initialLayoutGroupConfig","projection","type","initialPromotionConfig","layoutId","dragConstraints","layoutScroll","layoutRoot","layoutCrossfade","getClosestProjectingNode","setOptions","alwaysMeasureLayout","Boolean","animationType","crossfade","createProjectionNode","isMounted","update","optimisedAppearId","wantsHandoff","MotionHandoffIsComplete","MotionHasOptimisedAnimation","MotionIsMounted","updateFeatures","scheduleRenderMicrotask","animationState","animateChanges","queueMicrotask","_window$MotionHandoff2","_window3","MotionHandoffMarkAsComplete","enteringChildren","createMotionComponent","_Component$displayNam","preloadedFeatures","features","featureDefinitions","loadFeatures","useVisualState","MotionDOMComponent","MeasureLayout","configAndProps","useLayoutId","useStrictMode","layoutProjection","combined","ProjectionNode","getProjectionFunctionality","jsxs","Provider","value","jsx","displayName","ForwardRefMotionComponent","forwardRef","_ref2","layoutGroupId","id","createMotionProxy","Proxy","componentCache","Map","factory","_target","set","AnimationFeature","Feature","constructor","node","super","updateAnimationControlsSubscription","this","getProps","unmountControls","subscribe","prevAnimate","prevProps","_this$unmountControls","reset","ExitAnimationFeature","isPresent","onExitComplete","prevIsPresent","prevPresenceContext","exitAnimation","setActive","then","register","animations","extractEventInfo","event","point","x","pageX","y","pageY","addPointerEvent","eventName","handler","addPointerInfo","getContextWindow","ownerDocument","defaultView","distance","a","b","Math","abs","overflowStyles","PanSession","handlers","contextWindow","dragSnapToOrigin","distanceThreshold","element","startEvent","lastMoveEvent","lastMoveEventInfo","scrollPositions","removeScrollListeners","onElementScroll","handleScroll","onWindowScroll","updatePoint","info","getPanInfo","history","isPanStarted","isDistancePastThreshold","xDelta","yDelta","sqrt","distance2D","offset","timestamp","push","onStart","onMove","handlePointerMove","transformPoint","handlePointerUp","end","onEnd","onSessionEnd","resumeAnimation","panInfo","initialInfo","onSessionStart","removeListeners","pipe","startScrollTracking","parentElement","getComputedStyle","overflowX","overflowY","scrollLeft","scrollTop","scrollX","scrollY","addEventListener","capture","passive","removeEventListener","isWindow","delta","updateHandlers","clear","subtractPoint","lastDevicePoint","startDevicePoint","velocity","getVelocity","timeDelta","timestampedPoint","lastPoint","time","currentVelocity","Infinity","calcRelativeAxisConstraints","axis","min","max","calcViewportAxisConstraints","layoutAxis","constraintsAxis","defaultElastic","resolveAxisElastic","dragElastic","minLabel","maxLabel","resolvePointElastic","label","elementDragControls","WeakMap","VisualElementDragControls","openDragLock","isDragging","currentDirection","originPoint","constraints","hasMutatedConstraints","elastic","latestPointerEvent","latestPanInfo","start","originEvent","snapToCursor","panSession","stopAnimation","pauseAnimation","dragPropagation","onDragStart","resolveConstraints","isAnimationBlocked","getAxisMotionValue","measuredAxis","layoutBox","parseFloat","postRender","dragDirectionLock","onDirectionLock","onDrag","lockThreshold","direction","getCurrentDirection","updateAxis","render","stop","_this$getAxisMotionVa","getAnimationState","play","getTransformPagePoint","finalEvent","finalPanInfo","cancel","startAnimation","onDragEnd","_point","shouldDrag","axisValue","next","applyConstraints","_this$visualElement$p","measure","prevConstraints","resolveRefConstraints","top","left","bottom","right","calcRelativeConstraints","resolveDragElastic","relativeConstraints","rebaseAxisConstraints","onMeasureDragConstraints","constraintsElement","constraintsBox","root","measuredConstraints","calcViewportConstraints","userConstraints","dragMomentum","dragTransition","onDragTransitionEnd","momentumAnimations","bounceStiffness","bounceDamping","inertia","timeConstant","restDelta","restSpeed","startAxisValueAnimation","Promise","all","_this$getAxisMotionVa2","pause","_this$getAxisMotionVa3","dragKey","toUpperCase","externalMotionValue","getValue","scalePositionWithinConstraints","boxProgress","latest","origin","sourceLength","targetLength","progress","clamp","calcOrigin","updateScroll","updateLayout","addListeners","stopPointerListener","measureDragConstraints","stopMeasureLayoutListener","read","stopResizeListener","stopLayoutUpdateListener","hasLayoutChanged","motionValue","translate","DragGesture","removeGroupControls","noop","controls","dragControls","prevDragControls","asyncHandler","PanGesture","removePointerDownListener","onPointerDown","pointerDownEvent","session","createPanHandlers","onPanSessionStart","onPanStart","onPan","onPanEnd","hasTakenAnySnapshot","MeasureLayoutWithContext","componentDidMount","layoutGroup","switchLayoutGroup","group","add","didUpdate","safeToRemove","hasEverUpdated","getSnapshotBeforeUpdate","layoutDependency","willUpdate","promote","relegate","stack","getStack","members","componentDidUpdate","microtask","currentAnimation","isLead","componentWillUnmount","promoteContext","scheduleCheckAfterUnmount","remove","deregister","useId","usePresence","HTMLProjectionNode","handleHoverEvent","lifecycle","whileHover","callback","HoverGesture","_element","endEvent","FocusGesture","isActive","onFocus","isFocusVisible","matches","e","onBlur","handlePressEvent","HTMLButtonElement","disabled","PressGesture","press","success","useGlobalTarget","globalTapTarget","observerCallbacks","observers","fireObserverCallback","entry","fireAllObserverCallbacks","entries","forEach","observeIntersection","rootInteresectionObserver","lookupRoot","document","rootObservers","JSON","stringify","IntersectionObserver","initIntersectionObserver","observe","delete","unobserve","thresholdNames","InViewFeature","hasEnteredView","isInView","startObserver","viewport","margin","rootMargin","amount","once","threshold","isIntersecting","onViewportEnter","onViewportLeave","hasOptionsChanged","prevViewport","hasViewportOptionChanged","gestureAnimations","motion"],"ignoreList":[],"sourceRoot":""}